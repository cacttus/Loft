
//FastFile ff = new FastFile(globfn, System.IO.FileAccess.Read);
//ff.WriteInt32((Int32)g.GlobDensityState);
//ff.WriteInt32(g.Pos.x);
//ff.WriteInt32(g.Pos.y);
//ff.WriteInt32(g.Pos.z);
//if (g.Blocks == null)
//{
//   ff.WriteInt32(0);
//}
//else
//{
//   byte[] data = Gu.Serialize(g.Blocks);
//   ff.WriteInt32(g.Blocks.Length);
//   ff.WriteBlocks(g.Blocks);
//}
//ff.Close();


//unsafe
//{
//   int GlobMaxFileSize = sizeof(Int32) * 4 + sizeof(Int32) + sizeof(Block) * GlobBlocksX * GlobBlocksY * GlobBlocksZ;


//   using (var filestream = System.IO.File.OpenWrite(globfn))
//   using (MemoryMappedFile mmf = MemoryMappedFile.CreateFromFile(filestream, "test", GlobMaxFileSize, MemoryMappedFileAccess.ReadWrite, 
//      new MemoryMappedFileSecurity(), HandleInheritability.Inheritable, true))
//   using (MemoryMappedViewStream stream = mmf.CreateViewStream())
//   using(BinaryWriter writer = new BinaryWriter(stream))
//   {
//      writer.Write((Int32)g.GlobDensityState);
//      writer.Write((Int32)g.Pos.x);
//      writer.Write((Int32)g.Pos.y);
//      writer.Write((Int32)g.Pos.z);
//      if (g.Blocks == null)
//      {
//         writer.Write((Int32)0);
//      }
//      else
//      {
//         byte[] data = Gu.Serialize(g.Blocks);
//         writer.Write(g.Blocks.Length);
//         stream.Write(
//         writer.Write((byte*)g.Blocks);
//      }

//      System.IO.File.WriteAllBytes(stream.);
//   }
//}

//FastFile ff = new FastFile(globfn, System.IO.FileAccess.Write);
//ff.WriteInt32((Int32)g.GlobDensityState);
//ff.WriteInt32(g.Pos.x);
//ff.WriteInt32(g.Pos.y);
//ff.WriteInt32(g.Pos.z);
//if (g.Blocks == null)
//{
//   ff.WriteInt32(0);
//}
//else
//{
//   byte[] data = Gu.Serialize(g.Blocks);
//   ff.WriteInt32(g.Blocks.Length);
//   ff.WriteBlocks(g.Blocks);
//}
//ff.Close();

//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Text;
//using System.Threading.Tasks;
//using System.IO;
//using System.Runtime.InteropServices;

//namespace PirateCraft
//{
//   public class FastFile_InMemory
//   {
//      FileStream fileStream;
//      //UnmanagedMemoryStream unmanagedStream;
//      FileAccess fileAccess;
//      SafeBuffer safeBuffer;

//      System.IO.MemoryMappedFiles.MemoryMappedViewStream stream;

//      public FastFile_InMemory(string path, FileAccess access)
//      {
//         if(access == FileAccess.Read)
//         {
//            byte[] bytes = File.ReadAllBytes(path);
//            safeBuffer = new SafeBuffer(bytes.Length, sizeof(byte));
//         }
//         fileStream = new FileStream(path, FileMode.OpenOrCreate, access);
//         fileAccess = access; 
//      }
//      public unsafe void WriteInt32(Int32 n)
//      {
//         Gu.Assert(fileAccess == FileAccess.Write);

//         byte* b = (byte*)&n;
//         using (var us = new UnmanagedMemoryStream(b, Marshal.SizeOf(default(Int32)))) 
//            us.CopyTo(fileStream);
//      }
//      public unsafe void WriteBlocks(Block[] n) 
//      {
//         Gu.Assert(fileAccess == FileAccess.Write);

//         GCHandle h = GCHandle.Alloc(n, GCHandleType.Pinned);
//         IntPtr p = h.AddrOfPinnedObject();

//         byte* b = (byte*)&p;
//         using (var us = new UnmanagedMemoryStream(b, Marshal.SizeOf(default(Int32))))
//            us.CopyTo(fileStream);

//         h.Free();
//      }
//      public unsafe Int32 ReadInt32()
//      {
//         Gu.Assert(fileAccess == FileAccess.Read);

//         Int32 ret;
//         fileStream.Read()
//         byte* b = (byte*)&n;
//         using (var us = new UnmanagedMemoryStream(b, Marshal.SizeOf(default(Int32))))
//            us.Read(fileStream);
//      }
//      public unsafe Block[] ReadBlocks()
//      {
//         Gu.Assert(fileAccess == FileAccess.Read);

//         GCHandle h = GCHandle.Alloc(n, GCHandleType.Pinned);
//         IntPtr p = h.AddrOfPinnedObject();

//         byte* b = (byte*)&p;
//         using (var us = new UnmanagedMemoryStream(b, Marshal.SizeOf(default(Int32))))
//            us.CopyTo(fileStream);

//         h.Free();
//      }
//      public void Close()
//      {
//         fileStream.Dispose();
//         fileStream.Close();
//      }
//   }
//}


      //crush box along ray
      //crush ellipsoid along ray
      //do ray intersection test. This is easiest method
      vec3 line_p1 = ray.Origin;
      vec3 line_p2 = ray.Origin + ray.Dir;

      vec3 e_p1 = ray.Dir.normalized() * ray.Radius + ray.Origin;
      vec3 e_p2 = ray.Dir.normalized() * -ray.Radius + ray.Origin;
      float e_min = Line3f.pointOnLine_t(line_p1, line_p2, e_p1);
      float e_max = Line3f.pointOnLine_t(line_p1, line_p2, e_p2);
      float tmin = Line3f.pointOnLine_t(line_p1, line_p2, _min);
      float tmax = Line3f.pointOnLine_t(line_p1, line_p2, _max);
      if (tmin > tmax)
      {
        float tmp = tmin;
        tmin = tmax;
        tmax = tmp;
      }
      if (e_min > e_max)
      {
        float tmp = e_min;
        e_min = e_max;
        e_max = tmp;
      }











      float tx1, tx2;
      vec3 side = new vec3(0, 0, 0);
      vec3 radius_sign;


      if (ray.Origin.x < _min.x)
      {
        side.x = _min.x;
        radius_sign.x = 1;
      }
      else if (ray.Origin.x > _max.x)
      {
        side.x = _max.x;
        radius_sign.x = -1;
      }
      else
      {
        side.x = ray.Origin.x; //we are in the cube already
        radius_sign.x = 0;
      }

      if (ray.Origin.y < _min.y)
      {
        side.y = _min.y;
        radius_sign.y = 1;
      }
      else if (ray.Origin.y > _max.y)
      {
        side.y = _max.y;
        radius_sign.y = -1;
      }
      else
      {
        side.y = ray.Origin.y; //we are in the cube already
        radius_sign.y = 0;
      }

      if (ray.Origin.z < _min.z)
      {
        side.z = _min.z;
        radius_sign.z = 1;
      }
      else if (ray.Origin.z > _max.z)
      {
        side.z = _max.z;
        radius_sign.z = -1;
      }
      else
      {
        side.z = ray.Origin.z; //we are in the cube already
        radius_sign.z = 0;
      }

      //if (ray.Origin.x < _min.x)
      //{
      //  side.x = _min.x;
      //  radius_sign.x = 1;
      //}
      //else if (ray.Origin.x > _max.x)
      //{
      //  side.x = _max.x;
      //  radius_sign.x = -1;
      //}
      //else
      //{
      //  side.x = ray.Origin.x; //we are in the cube already
      //  radius_sign.x = 0;
      //}

      //if (ray.Origin.y < _min.y)
      //{
      //  side.y = _min.y;
      //  radius_sign.y = 1;
      //}
      //else if (ray.Origin.y > _max.y)
      //{
      //  side.y = _max.y;
      //  radius_sign.y = -1;
      //}
      //else
      //{
      //  side.y = ray.Origin.y; //we are in the cube already
      //  radius_sign.y = 0;
      //}

      //if (ray.Origin.z < _min.z)
      //{
      //  side.z = _min.z;
      //  radius_sign.z = 1;
      //}
      //else if (ray.Origin.z > _max.z)
      //{
      //  side.z = _max.z;
      //  radius_sign.z = -1;
      //}
      //else
      //{
      //  side.z = ray.Origin.z; //we are in the cube already
      //  radius_sign.z = 0;
      //}

      //vec3 tmin = (side - ray.Origin - ray.Radius* radius_sign) / ray.Dir;
      //vec3 tmax = (side - ray.Origin + ray.Radius* radius_sign) / ray.Dir;





      return false;

      vec3 R = 1.0f / ray.Radius;
      vec3 V = ray.Dir;
      vec3 O = ray.Origin;
      vec3 X = this._min;

      float t = 9999999;
      float tmin_a = 9999999;
      float tmin_b = 9999999;
      float tmax_a = 9999999;
      float tmax_b = 9999999;
      bool b1 = Ellipse_Box_Velocity(R, V, O, side, ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_min.x, _min.y, _min.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_max.x, _min.y, _min.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_min.x, _max.y, _min.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_max.x, _max.y, _min.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_min.x, _min.y, _max.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_max.x, _min.y, _max.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_min.x, _max.y, _max.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_max.x, _max.y, _max.z), ref tmin_a, ref tmin_b);

      if (b1)
      {
        bh.IsHit = true;
        bh._t = Math.Min(tmin_a, tmin_b);
      }
      else
      {
        if (RayIntersectExclusive(ray, ref bh))
        {
          //so our algorithm didn't hit but the ray did
          int n = 0;
          n++;
        }
        bh.IsHit = false;
        bh._t = 9999999;
      }

      return bh.IsHit;
      //float txmin1, txmin2, txmax1, txmax2, tymin1, tymin2, tymax1, tymax2, tzmin1, tzmin2, tzmax1, tzmax2;
      //float rx = ray.Radius * ray.Radius;
      //float ry = ray.Radius * ray.Radius;//ellipsoid = rx.. y z
      //float rz = ray.Radius * ray.Radius;

      //float txmin, txmax, tymin, tymax, tzmin, tzmax;
      ////This solution is essentially solving P0 + Vt == r^2
      ////if (ray.Dir.x == 0)
      ////{
      //vec3 r2 = new vec3(ray.Radius * ray.Radius, ray.Radius * ray.Radius, ray.Radius * ray.Radius);
      //vec3 tmin1 = (_min - ray.Origin + r2) / ray.Dir;
      //vec3 tmin2 = (_min - ray.Origin - r2) / ray.Dir;
      //vec3 tmax1 = (_max - ray.Origin + r2) / ray.Dir;
      //vec3 tmax2 = (_max - ray.Origin - r2) / ray.Dir;
      ////this is correct but determining which time is the correct time.
      ////wopud not be min collision time, since if the result is -infinity 
      ////[0,1] along ray
      ////we can only collide when 

      ////}
      ////else
      ////{
      //txmin1 = (_min.x - ray.Origin.x + rx) * (ray.InvDir.x);
      //txmin2 = (_min.x - ray.Origin.x - rx) * (ray.InvDir.x);
      //txmax1 = (_max.x - ray.Origin.x + rx) * (ray.InvDir.x);
      //txmax2 = (_max.x - ray.Origin.x - rx) * (ray.InvDir.x);
      //txmin = Math.Min(txmin1, txmin2);
      //txmax = Math.Min(txmax1, txmax2);
      ////}

      ////if (ray.Dir.y == 0)
      ////{
      ////}
      ////else
      ////{
      //tymin1 = (_min.y - ray.Origin.y + ry) * (ray.InvDir.y);
      //tymin2 = (_min.y - ray.Origin.y - ry) * (ray.InvDir.y);
      //tymax1 = (_max.y - ray.Origin.y + ry) * (ray.InvDir.y);
      //tymax2 = (_max.y - ray.Origin.y - ry) * (ray.InvDir.y);
      //tymin = Math.Min(tymin1, tymin2);
      //tymax = Math.Min(tymax1, tymax2);
      ////}

      ////if ((txmin > tymax) || (tymin > txmax))
      ////{
      ////  bh.IsHit = false;
      ////  return false;
      ////}
      //if (tymin > txmin)
      //{
      //  txmin = tymin;
      //}
      //if (tymax < txmax)
      //{
      //  txmax = tymax;
      //}

      ////if (ray.Dir.z == 0)
      ////{

      ////}
      ////else
      ////{
      //tzmin1 = (_min.z - ray.Origin.z + rz) * (ray.InvDir.z);
      //tzmin2 = (_min.z - ray.Origin.z - rz) * (ray.InvDir.z);
      //tzmax1 = (_max.z - ray.Origin.z + rz) * (ray.InvDir.z);
      //tzmax2 = (_max.z - ray.Origin.z - rz) * (ray.InvDir.z);
      //tzmin = Math.Min(tzmin1, tzmin2);
      //tzmax = Math.Min(tzmax1, tzmax2);
      ////}

      ////if ((txmin > tzmax) || (tzmin > txmax))
      ////{
      ////  bh.IsHit = false;
      ////  return false;
      ////}
      //if (tzmin > txmin)
      //{
      //  txmin = tzmin;
      //}
      //if (tzmax < txmax)
      //{
      //  txmax = tzmax;
      //}

      //bh.IsHit = ((txmin > 0.0f) && (txmax <= ray.Length));
      //bh._t = txmin;

      //return bh.IsHit;


          private bool Ellipse_Box_Velocity(vec3 R, vec3 V, vec3 O, vec3 X, ref float t1, ref float t2)
    {
      vec3 P = O - X;// O-X, or, O+X

      float A =
        R.x * -V.x * -V.x +
        R.y * -V.y * -V.y +
        R.z * -V.z * -V.z;

      float B =
        2 * P.x * -V.x * R.x +
        2 * P.y * -V.y * R.y +
        2 * P.z * -V.z * R.z;

      float C =
        P.x * P.x * R.x +
        P.y * P.y * R.y +
        P.z * P.z * R.z
        - 1.0f;

      //- Bx version
      float A2 =
        R.x * V.x * V.x +
        R.y * V.y * V.y +
        R.z * V.z * V.z;

      float B2 =
        2 * O.x * V.x * R.x +
        2 * O.y * V.y * R.y +
        2 * O.z * V.z * R.z;

      float C2 =
        O.x * O.x * R.x - X.x +
        O.y * O.y * R.y - X.y +
        O.z * O.z * R.z - X.z
        - 1.0f;


      //same as A, B, C
      //float A =
      //  R.x * V.x * V.x +
      //  R.y * V.y * V.y +
      //  R.z * V.z * V.z;
      //float B =
      //  2 * R.x * O.x * V.x - 2 * R.x * V.x * X.x +
      //  2 * R.y * O.y * V.y - 2 * R.y * V.y * X.y +
      //  2 * R.z * O.z * V.z - 2 * R.z * V.z * X.z;
      //float C =
      //  R.x * O.x * O.x - 2 * R.x * O.x * X.x + R.x * X.x * X.x +
      //  R.y * O.y * O.y - 2 * R.y * O.y * X.y + R.y * X.y * X.y +
      //  R.z * O.z * O.z - 2 * R.z * O.z * X.z + R.z * X.z * X.z
      //  - 1.0f; //note .. -1

      //A = A2;
      //B = B2;
      //C = C2;

      float descriminant = B * B - 4 * A * C;
      if (descriminant < 0)
      {
        return false;
      }
      else
      {
        t1 = (-B - MathUtils.sqrtf(descriminant)) / 2 * A;
        t2 = (-B + MathUtils.sqrtf(descriminant)) / 2 * A;

        if (t1 > t2)
        {
          float tmp = t1;
          t1 = t2;
          t2 = tmp;
        }

        if (t1 >= 0 && t2 <= 1)
        {
          return true;
        }
        else
        {
          return false;
        }
      }
      return false;
    }