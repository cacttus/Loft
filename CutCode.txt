
//FastFile ff = new FastFile(globfn, System.IO.FileAccess.Read);
//ff.WriteInt32((Int32)g.GlobDensityState);
//ff.WriteInt32(g.Pos.x);
//ff.WriteInt32(g.Pos.y);
//ff.WriteInt32(g.Pos.z);
//if (g.Blocks == null)
//{
//   ff.WriteInt32(0);
//}
//else
//{
//   byte[] data = Gu.Serialize(g.Blocks);
//   ff.WriteInt32(g.Blocks.Length);
//   ff.WriteBlocks(g.Blocks);
//}
//ff.Close();


//unsafe
//{
//   int GlobMaxFileSize = sizeof(Int32) * 4 + sizeof(Int32) + sizeof(Block) * GlobBlocksX * GlobBlocksY * GlobBlocksZ;


//   using (var filestream = System.IO.File.OpenWrite(globfn))
//   using (MemoryMappedFile mmf = MemoryMappedFile.CreateFromFile(filestream, "test", GlobMaxFileSize, MemoryMappedFileAccess.ReadWrite, 
//      new MemoryMappedFileSecurity(), HandleInheritability.Inheritable, true))
//   using (MemoryMappedViewStream stream = mmf.CreateViewStream())
//   using(BinaryWriter writer = new BinaryWriter(stream))
//   {
//      writer.Write((Int32)g.GlobDensityState);
//      writer.Write((Int32)g.Pos.x);
//      writer.Write((Int32)g.Pos.y);
//      writer.Write((Int32)g.Pos.z);
//      if (g.Blocks == null)
//      {
//         writer.Write((Int32)0);
//      }
//      else
//      {
//         byte[] data = Gu.Serialize(g.Blocks);
//         writer.Write(g.Blocks.Length);
//         stream.Write(
//         writer.Write((byte*)g.Blocks);
//      }

//      System.IO.File.WriteAllBytes(stream.);
//   }
//}

//FastFile ff = new FastFile(globfn, System.IO.FileAccess.Write);
//ff.WriteInt32((Int32)g.GlobDensityState);
//ff.WriteInt32(g.Pos.x);
//ff.WriteInt32(g.Pos.y);
//ff.WriteInt32(g.Pos.z);
//if (g.Blocks == null)
//{
//   ff.WriteInt32(0);
//}
//else
//{
//   byte[] data = Gu.Serialize(g.Blocks);
//   ff.WriteInt32(g.Blocks.Length);
//   ff.WriteBlocks(g.Blocks);
//}
//ff.Close();

//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Text;
//using System.Threading.Tasks;
//using System.IO;
//using System.Runtime.InteropServices;

//namespace PirateCraft
//{
//   public class FastFile_InMemory
//   {
//      FileStream fileStream;
//      //UnmanagedMemoryStream unmanagedStream;
//      FileAccess fileAccess;
//      SafeBuffer safeBuffer;

//      System.IO.MemoryMappedFiles.MemoryMappedViewStream stream;

//      public FastFile_InMemory(string path, FileAccess access)
//      {
//         if(access == FileAccess.Read)
//         {
//            byte[] bytes = File.ReadAllBytes(path);
//            safeBuffer = new SafeBuffer(bytes.Length, sizeof(byte));
//         }
//         fileStream = new FileStream(path, FileMode.OpenOrCreate, access);
//         fileAccess = access; 
//      }
//      public unsafe void WriteInt32(Int32 n)
//      {
//         Gu.Assert(fileAccess == FileAccess.Write);

//         byte* b = (byte*)&n;
//         using (var us = new UnmanagedMemoryStream(b, Marshal.SizeOf(default(Int32)))) 
//            us.CopyTo(fileStream);
//      }
//      public unsafe void WriteBlocks(Block[] n) 
//      {
//         Gu.Assert(fileAccess == FileAccess.Write);

//         GCHandle h = GCHandle.Alloc(n, GCHandleType.Pinned);
//         IntPtr p = h.AddrOfPinnedObject();

//         byte* b = (byte*)&p;
//         using (var us = new UnmanagedMemoryStream(b, Marshal.SizeOf(default(Int32))))
//            us.CopyTo(fileStream);

//         h.Free();
//      }
//      public unsafe Int32 ReadInt32()
//      {
//         Gu.Assert(fileAccess == FileAccess.Read);

//         Int32 ret;
//         fileStream.Read()
//         byte* b = (byte*)&n;
//         using (var us = new UnmanagedMemoryStream(b, Marshal.SizeOf(default(Int32))))
//            us.Read(fileStream);
//      }
//      public unsafe Block[] ReadBlocks()
//      {
//         Gu.Assert(fileAccess == FileAccess.Read);

//         GCHandle h = GCHandle.Alloc(n, GCHandleType.Pinned);
//         IntPtr p = h.AddrOfPinnedObject();

//         byte* b = (byte*)&p;
//         using (var us = new UnmanagedMemoryStream(b, Marshal.SizeOf(default(Int32))))
//            us.CopyTo(fileStream);

//         h.Free();
//      }
//      public void Close()
//      {
//         fileStream.Dispose();
//         fileStream.Close();
//      }
//   }
//}


      //crush box along ray
      //crush ellipsoid along ray
      //do ray intersection test. This is easiest method
      vec3 line_p1 = ray.Origin;
      vec3 line_p2 = ray.Origin + ray.Dir;

      vec3 e_p1 = ray.Dir.normalized() * ray.Radius + ray.Origin;
      vec3 e_p2 = ray.Dir.normalized() * -ray.Radius + ray.Origin;
      float e_min = Line3f.pointOnLine_t(line_p1, line_p2, e_p1);
      float e_max = Line3f.pointOnLine_t(line_p1, line_p2, e_p2);
      float tmin = Line3f.pointOnLine_t(line_p1, line_p2, _min);
      float tmax = Line3f.pointOnLine_t(line_p1, line_p2, _max);
      if (tmin > tmax)
      {
        float tmp = tmin;
        tmin = tmax;
        tmax = tmp;
      }
      if (e_min > e_max)
      {
        float tmp = e_min;
        e_min = e_max;
        e_max = tmp;
      }











      float tx1, tx2;
      vec3 side = new vec3(0, 0, 0);
      vec3 radius_sign;


      if (ray.Origin.x < _min.x)
      {
        side.x = _min.x;
        radius_sign.x = 1;
      }
      else if (ray.Origin.x > _max.x)
      {
        side.x = _max.x;
        radius_sign.x = -1;
      }
      else
      {
        side.x = ray.Origin.x; //we are in the cube already
        radius_sign.x = 0;
      }

      if (ray.Origin.y < _min.y)
      {
        side.y = _min.y;
        radius_sign.y = 1;
      }
      else if (ray.Origin.y > _max.y)
      {
        side.y = _max.y;
        radius_sign.y = -1;
      }
      else
      {
        side.y = ray.Origin.y; //we are in the cube already
        radius_sign.y = 0;
      }

      if (ray.Origin.z < _min.z)
      {
        side.z = _min.z;
        radius_sign.z = 1;
      }
      else if (ray.Origin.z > _max.z)
      {
        side.z = _max.z;
        radius_sign.z = -1;
      }
      else
      {
        side.z = ray.Origin.z; //we are in the cube already
        radius_sign.z = 0;
      }

      //if (ray.Origin.x < _min.x)
      //{
      //  side.x = _min.x;
      //  radius_sign.x = 1;
      //}
      //else if (ray.Origin.x > _max.x)
      //{
      //  side.x = _max.x;
      //  radius_sign.x = -1;
      //}
      //else
      //{
      //  side.x = ray.Origin.x; //we are in the cube already
      //  radius_sign.x = 0;
      //}

      //if (ray.Origin.y < _min.y)
      //{
      //  side.y = _min.y;
      //  radius_sign.y = 1;
      //}
      //else if (ray.Origin.y > _max.y)
      //{
      //  side.y = _max.y;
      //  radius_sign.y = -1;
      //}
      //else
      //{
      //  side.y = ray.Origin.y; //we are in the cube already
      //  radius_sign.y = 0;
      //}

      //if (ray.Origin.z < _min.z)
      //{
      //  side.z = _min.z;
      //  radius_sign.z = 1;
      //}
      //else if (ray.Origin.z > _max.z)
      //{
      //  side.z = _max.z;
      //  radius_sign.z = -1;
      //}
      //else
      //{
      //  side.z = ray.Origin.z; //we are in the cube already
      //  radius_sign.z = 0;
      //}

      //vec3 tmin = (side - ray.Origin - ray.Radius* radius_sign) / ray.Dir;
      //vec3 tmax = (side - ray.Origin + ray.Radius* radius_sign) / ray.Dir;





      return false;

      vec3 R = 1.0f / ray.Radius;
      vec3 V = ray.Dir;
      vec3 O = ray.Origin;
      vec3 X = this._min;

      float t = 9999999;
      float tmin_a = 9999999;
      float tmin_b = 9999999;
      float tmax_a = 9999999;
      float tmax_b = 9999999;
      bool b1 = Ellipse_Box_Velocity(R, V, O, side, ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_min.x, _min.y, _min.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_max.x, _min.y, _min.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_min.x, _max.y, _min.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_max.x, _max.y, _min.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_min.x, _min.y, _max.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_max.x, _min.y, _max.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_min.x, _max.y, _max.z), ref tmin_a, ref tmin_b);
      b1 = b1 || Ellipse_Box_Velocity(R, V, O, new vec3(_max.x, _max.y, _max.z), ref tmin_a, ref tmin_b);

      if (b1)
      {
        bh.IsHit = true;
        bh._t = Math.Min(tmin_a, tmin_b);
      }
      else
      {
        if (RayIntersectExclusive(ray, ref bh))
        {
          //so our algorithm didn't hit but the ray did
          int n = 0;
          n++;
        }
        bh.IsHit = false;
        bh._t = 9999999;
      }

      return bh.IsHit;
      //float txmin1, txmin2, txmax1, txmax2, tymin1, tymin2, tymax1, tymax2, tzmin1, tzmin2, tzmax1, tzmax2;
      //float rx = ray.Radius * ray.Radius;
      //float ry = ray.Radius * ray.Radius;//ellipsoid = rx.. y z
      //float rz = ray.Radius * ray.Radius;

      //float txmin, txmax, tymin, tymax, tzmin, tzmax;
      ////This solution is essentially solving P0 + Vt == r^2
      ////if (ray.Dir.x == 0)
      ////{
      //vec3 r2 = new vec3(ray.Radius * ray.Radius, ray.Radius * ray.Radius, ray.Radius * ray.Radius);
      //vec3 tmin1 = (_min - ray.Origin + r2) / ray.Dir;
      //vec3 tmin2 = (_min - ray.Origin - r2) / ray.Dir;
      //vec3 tmax1 = (_max - ray.Origin + r2) / ray.Dir;
      //vec3 tmax2 = (_max - ray.Origin - r2) / ray.Dir;
      ////this is correct but determining which time is the correct time.
      ////wopud not be min collision time, since if the result is -infinity 
      ////[0,1] along ray
      ////we can only collide when 

      ////}
      ////else
      ////{
      //txmin1 = (_min.x - ray.Origin.x + rx) * (ray.InvDir.x);
      //txmin2 = (_min.x - ray.Origin.x - rx) * (ray.InvDir.x);
      //txmax1 = (_max.x - ray.Origin.x + rx) * (ray.InvDir.x);
      //txmax2 = (_max.x - ray.Origin.x - rx) * (ray.InvDir.x);
      //txmin = Math.Min(txmin1, txmin2);
      //txmax = Math.Min(txmax1, txmax2);
      ////}

      ////if (ray.Dir.y == 0)
      ////{
      ////}
      ////else
      ////{
      //tymin1 = (_min.y - ray.Origin.y + ry) * (ray.InvDir.y);
      //tymin2 = (_min.y - ray.Origin.y - ry) * (ray.InvDir.y);
      //tymax1 = (_max.y - ray.Origin.y + ry) * (ray.InvDir.y);
      //tymax2 = (_max.y - ray.Origin.y - ry) * (ray.InvDir.y);
      //tymin = Math.Min(tymin1, tymin2);
      //tymax = Math.Min(tymax1, tymax2);
      ////}

      ////if ((txmin > tymax) || (tymin > txmax))
      ////{
      ////  bh.IsHit = false;
      ////  return false;
      ////}
      //if (tymin > txmin)
      //{
      //  txmin = tymin;
      //}
      //if (tymax < txmax)
      //{
      //  txmax = tymax;
      //}

      ////if (ray.Dir.z == 0)
      ////{

      ////}
      ////else
      ////{
      //tzmin1 = (_min.z - ray.Origin.z + rz) * (ray.InvDir.z);
      //tzmin2 = (_min.z - ray.Origin.z - rz) * (ray.InvDir.z);
      //tzmax1 = (_max.z - ray.Origin.z + rz) * (ray.InvDir.z);
      //tzmax2 = (_max.z - ray.Origin.z - rz) * (ray.InvDir.z);
      //tzmin = Math.Min(tzmin1, tzmin2);
      //tzmax = Math.Min(tzmax1, tzmax2);
      ////}

      ////if ((txmin > tzmax) || (tzmin > txmax))
      ////{
      ////  bh.IsHit = false;
      ////  return false;
      ////}
      //if (tzmin > txmin)
      //{
      //  txmin = tzmin;
      //}
      //if (tzmax < txmax)
      //{
      //  txmax = tzmax;
      //}

      //bh.IsHit = ((txmin > 0.0f) && (txmax <= ray.Length));
      //bh._t = txmin;

      //return bh.IsHit;


          private bool Ellipse_Box_Velocity(vec3 R, vec3 V, vec3 O, vec3 X, ref float t1, ref float t2)
    {
      vec3 P = O - X;// O-X, or, O+X

      float A =
        R.x * -V.x * -V.x +
        R.y * -V.y * -V.y +
        R.z * -V.z * -V.z;

      float B =
        2 * P.x * -V.x * R.x +
        2 * P.y * -V.y * R.y +
        2 * P.z * -V.z * R.z;

      float C =
        P.x * P.x * R.x +
        P.y * P.y * R.y +
        P.z * P.z * R.z
        - 1.0f;

      //- Bx version
      float A2 =
        R.x * V.x * V.x +
        R.y * V.y * V.y +
        R.z * V.z * V.z;

      float B2 =
        2 * O.x * V.x * R.x +
        2 * O.y * V.y * R.y +
        2 * O.z * V.z * R.z;

      float C2 =
        O.x * O.x * R.x - X.x +
        O.y * O.y * R.y - X.y +
        O.z * O.z * R.z - X.z
        - 1.0f;


      //same as A, B, C
      //float A =
      //  R.x * V.x * V.x +
      //  R.y * V.y * V.y +
      //  R.z * V.z * V.z;
      //float B =
      //  2 * R.x * O.x * V.x - 2 * R.x * V.x * X.x +
      //  2 * R.y * O.y * V.y - 2 * R.y * V.y * X.y +
      //  2 * R.z * O.z * V.z - 2 * R.z * V.z * X.z;
      //float C =
      //  R.x * O.x * O.x - 2 * R.x * O.x * X.x + R.x * X.x * X.x +
      //  R.y * O.y * O.y - 2 * R.y * O.y * X.y + R.y * X.y * X.y +
      //  R.z * O.z * O.z - 2 * R.z * O.z * X.z + R.z * X.z * X.z
      //  - 1.0f; //note .. -1

      //A = A2;
      //B = B2;
      //C = C2;

      float descriminant = B * B - 4 * A * C;
      if (descriminant < 0)
      {
        return false;
      }
      else
      {
        t1 = (-B - MathUtils.sqrtf(descriminant)) / 2 * A;
        t2 = (-B + MathUtils.sqrtf(descriminant)) / 2 * A;

        if (t1 > t2)
        {
          float tmp = t1;
          t1 = t2;
          t2 = tmp;
        }

        if (t1 >= 0 && t2 <= 1)
        {
          return true;
        }
        else
        {
          return false;
        }
      }
      return false;
    }

        //public static void Render(Camera3D cam, List<MeshData> meshes, Shader m)
    //{
    //   //Render a single material to a group of meshes (faster)
    //   Gu.Assert(m != null);
    //   Gu.Assert(RenderState == RenderPipelineState.Begin);
    //   foreach (MeshData mesh in meshes)
    //   {
    //      mesh.Draw();
    //   }
    //}
    //public static void Render(Camera3D cam, WorldObject ob, Material m)
    //{
    //   //Render single material to a single object with object data included
    //   Gu.Assert(m != null);
    //   Gu.Assert(RenderState == RenderPipelineState.Begin);
    //   m.GpuRenderState.SetState();
    //   Render(cam, ob.Mesh, m.Shader, m.Shader);
    //}
    ////We're using instanced rendering so vs sohuld be instanced as well.
    //private static void Render(Camera3D bc, MeshData ms, Shader shader, Texture tex)// InstancedVisibleSet vs) << TODO
    //{

    //   Gu.Assert(RenderState == RenderPipelineState.Begin);

    //   if (tex != null)
    //   {
    //      //TODO material
    //      tex.Bind();
    //      GL.ActiveTexture(TextureUnit.Texture0);
    //   }

    //   Gpu.CheckGpuErrorsDbg();
    //   shader.Bind();
    //   ms.Draw();
    //   shader.Unbind();
    //   Gpu.CheckGpuErrorsDbg();

    //   if (tex != null)
    //   {
    //      tex.Unbind();
    //   }

    //   ////GL.Disable(EnableCap.CullFace);
    //   //GL.ClearColor(color.x, color.y, color.z, color.W);

    //   //_objMainShader = new BaseShader();
    //   //_objMainShader.Load();
    //}

    //        void renderGrid(float r, float g, float b, int nSlices, float fSliceWidth, Vec3f center)
    //        {
    //            GL.PushAttrib(AttribMask.AllAttribBits);

    //            GL.Disable(EnableCap.CullFace);

    //            float gridWidth_2 = nSlices * fSliceWidth / 2.0f;

    //            GL.LineWidth(1.0f);
    //            GL.Begin(PrimitiveType.Lines);
    //            GL.Color3(r, g, b);
    //            //Horiz lines
    //            for (int i = 0; i < nSlices + 1; ++i)
    //            {
    //                GL.Vertex3(center.x - (gridWidth_2),
    //                    center.y - 0,
    //                    center.z - (gridWidth_2) + (fSliceWidth * (float)i)
    //                    );
    //                GL.Vertex3(center.x + (gridWidth_2),
    //                    center.y - 0,
    //                    center.z - (gridWidth_2) + (fSliceWidth * (float)i)
    //                    );
    //            }
    //            for (int i = 0; i < nSlices + 1; ++i)
    //            {
    //                GL.Vertex3(center.x - (gridWidth_2) + (fSliceWidth * (float)i),
    //                    center.y - 0,
    //                    center.z - (gridWidth_2)
    //                    );
    //                GL.Vertex3(center.x - (gridWidth_2) + (fSliceWidth * (float)i),
    //                    center.y - 0,
    //                    center.z + (gridWidth_2)
    //                    );
    //            }
    //            GL.End();

    //            GL.PopAttrib();

    //   }





    public class BeamGrid
  {
    //Algorithm:
    //construct a grid of beams along each axis corresponding to the "air" between blocks
    // beams that have their tips at block faces are direct light
    // beams that pass laterally across faces are indirect light
    //when lights update - (every few frames or so)
    //  trace rays through the beams and compute light at each end of the beam for each block face +x+y+z,-x-y-z
    //update all visible globs that have been touched by the light update
    //send light data to the gpu as a separate buffer from the mesh buffer
    //TODO: we may use points for block faces in the future and a g shader, however that is too much work rn

    //Builds a grid of "beams" for hacky radiosity lighting 
    //This is .. so confusing .. fortunately.. it's just temporary (yeah, right)
    //The BeamsXYZ are the beams along that axis stacked on top of each other
    //Row = transmission axis, the axis that goes through the beams 
    //layer = layer axis, the axis that we iterate over
    //Iterate over X, Y, Z through each transmission beam topology = color
    // "Stacked Beam Grid"
    //The algorithm is inefficient it needs to have some hierarchical structure
    private SortedDictionary<ivec2, List<Beam>> BeamsX = new SortedDictionary<ivec2, List<Beam>>(new ivec2.ivec2ComparerYX());//layer=z, stack=y -> bars=x : +/- y
    private SortedDictionary<ivec2, List<Beam>> BeamsY = new SortedDictionary<ivec2, List<Beam>>(new ivec2.ivec2ComparerYX());//layer=z, stack=x -> bars=y : +/- x
    private SortedDictionary<ivec2, List<Beam>> BeamsZ = new SortedDictionary<ivec2, List<Beam>>(new ivec2.ivec2ComparerYX());//layer=x, stack=y -> bars=z : +/- z
    private int[] OrderX = new int[] { 0, 1, 2 }; //Iteration orders: bars, stack, layer
    private int[] OrderY = new int[] { 1, 0, 2 };
    private int[] OrderZ = new int[] { 2, 1, 0 };
    public long UpdateStamp { get; private set; } = 0;//Microseconds of last modified

    #region Public guys

    public void Build(World w, Drome d)
    {
      //Pass in: 0 = Beam axis, 1 = transmission axis (stack), 2 = iteration / integral axis (layer)
      BuildAxis(w, d, BeamsX, OrderX); // X -> ZY
      BuildAxis(w, d, BeamsY, OrderY);// Y -> ZX
      BuildAxis(w, d, BeamsZ, OrderZ);//Z -> YX
      Stitch(BeamsX);
      Stitch(BeamsY);
      Stitch(BeamsZ);
    }
    public vec3 GetBlockFaceColor(int iface, int bx, int by, int bz)
    {
      //face = 0 1 2 3 4 5
      // -x +x -y +y -z +z
      //Construct the beam axis for the given face
      // ContributeColor Direct
      // ContributeColor Indirect * 0.1
      // ContributeCOlor Indirect  * 0.1 
      //byxz - block index in drome
      Gu.Assert(BeamsX != null && BeamsY != null && BeamsZ != null);
      vec3 c_out = vec3.Zero;

      int off_x = 0, stack_x = 0, layer_x = 0;
      int off_y = 0, stack_y = 0, layer_y = 0;
      int off_z = 0, stack_z = 0, layer_z = 0;
      float mul_x = 0, mul_y = 0, mul_z = 0;
      float d_ct = 0.8f; //direct contrib
      float i_ct = 0.1f; //indirect contrib

      //Note: if we are outside drome, we'd need to use neighbor data, or have some mechanism to transmit this grid neighbor-wise
      if (iface == 0)
      {
        //-x
        bx -= 1;
        mul_x = d_ct;
        mul_y = mul_z = i_ct;
      }
      else if (iface == 1)
      {
        //+x
        bx += 1;
        mul_x = d_ct;
        mul_y = mul_z = i_ct;
      }
      else if (iface == 2)
      {
        //-y
        by -= 1;
        mul_y = d_ct;
        mul_x = mul_z = i_ct;
      }
      else if (iface == 3)
      {
        //+y
        by += 1;
        mul_y = d_ct;
        mul_x = mul_z = i_ct;
      }
      else if (iface == 4)
      {
        //-z
        bz -= 1;
        mul_z = d_ct;
        mul_y = mul_x = i_ct;
      }
      else if (iface == 5)
      {
        //+z
        bz += 1;
        mul_z = d_ct;
        mul_y = mul_x = i_ct;
      }

      off_x = bx;// x-> y, z
      stack_x = by;
      layer_x = bz;
      mul_x = d_ct;

      off_y = by; // y -> x, z
      stack_y = bx;
      layer_y = bz;
      mul_y = i_ct;

      off_z = bz; // z -> y, x
      stack_z = by;
      layer_z = bx;
      mul_z = i_ct;

      ContributeColor(ref c_out, mul_x, off_x, stack_x, layer_x, BeamsX);
      ContributeColor(ref c_out, mul_y, off_y, stack_y, layer_y, BeamsY);
      ContributeColor(ref c_out, mul_z, off_z, stack_z, layer_z, BeamsZ);

      return c_out;
    }
    public void ApplyDirLight(vec3 dir, vec3 color)
    {
      UpdateStamp = Gu.Microseconds();

      //Applies a directional light / sun to the grid
      ApplyDirLight(dir, color, BeamsX, OrderX);
      ApplyDirLight(dir, color, BeamsY, OrderY);
      ApplyDirLight(dir, color, BeamsZ, OrderZ);
    }

    #endregion

    #region Private guys

    private void ContributeColor(ref vec3 out_color, float contribution, int block, int stack, int layer, SortedDictionary<ivec2, List<Beam>> beam_grid)
    {
      //semi-transparent blocks should really be their own beams.
      List<Beam> beam_stack;
      if (beam_grid.TryGetValue(new ivec2(stack, layer), out beam_stack))
      {
        foreach (var bb in beam_stack)
        {
          if (block >= bb.min && block <= bb.max)
          {
            float dist = ((float)block - (float)bb.min + 1.0f) / ((float)bb.max - (float)bb.min + 1.0f); //+1 because a block is one unit and max-min is one unit minimum
            out_color += bb.color_min + (bb.color_max - bb.color_min) * dist;// ((1 - dist) * bb.color_min + (dist) * bb.color_max) * contribution;
            return;
          }

        }
      }
      //Note this function should ALWAYS exit early. if it does't there is an error

    }
    private void ApplyDirLight(vec3 dir, vec3 color, SortedDictionary<ivec2, List<Beam>> stacked_beam_grid, int[] idx)
    {
      int[] max = new int[] {
        (idx[0] == 0) ? World.DromeBlocksX : ((idx[0] == 1) ? World.DromeBlocksY : World.DromeBlocksZ),
        (idx[1] == 0) ? World.DromeBlocksX : ((idx[1] == 1) ? World.DromeBlocksY : World.DromeBlocksZ),
        (idx[2] == 0) ? World.DromeBlocksX : ((idx[2] == 1) ? World.DromeBlocksY : World.DromeBlocksZ),
      };


      float light_axis = (idx[0] == 0) ? dir.y : ((idx[0] == 1) ? dir.x : dir.y);

      bool negative = light_axis < 0;
      float light_value = Math.Abs(light_axis);
      float ambient = 0.1f;

      //make smeitransparent blocks their own beams 
      // then transmit light from beam end to beam end 
      // or some kind of transmission data between beam ends .. simpler but less accurate
      for (int layer = 0; layer < max[2]; layer++) //trans
      {
        for (int stack = 0; stack < max[0]; stack++)
        {
          int stack_reversed_or_not = stack;
          if (negative)
          {
            stack_reversed_or_not = max[0] - stack - 1;
          }
          ivec2 vval = new ivec2(stack_reversed_or_not, layer);
          if (stacked_beam_grid.TryGetValue(vval, out var beam_chain))
          {
            //beams should not be null
            for (int iBeam = 0; iBeam < beam_chain.Count; iBeam++)
            {
              Beam our_beam = beam_chain[iBeam];
              List<Beam> neighbor = null;

              if (iBeam == 0)
              {
                //set initial light on the drome edge
                //our_beam.color_min = our_beam.color_max = transY * color;
                our_beam.light_min = our_beam.light_max = light_value + ambient;
                our_beam.color_max = our_beam.color_min = color;
              }

              if (!negative)
              {
                if (our_beam.next == null)
                {
                  continue;
                }
                neighbor = our_beam.next;
              }
              else
              {
                if (our_beam.prev == null)
                {
                  continue;
                }
                neighbor = our_beam.prev;
              }


              //loop all children and send the light
              foreach (var his_neighbor in neighbor)
              {
                //Skip transmission for now.. later
                float a1 = our_beam.min, a2 = our_beam.max, b1 = his_neighbor.min, b2 = his_neighbor.max;

                float t_decay = CalculateDecay(a1, a2, b1, b2);
                //Send light - light whole beam for now
                his_neighbor.light_min = t_decay * light_value + ambient;
                his_neighbor.light_max = t_decay * light_value + ambient;

                his_neighbor.color_min = his_neighbor.light_min * color;
                his_neighbor.color_max = his_neighbor.light_max * color;

              }
            }
          }
        }
      }
    }
    private float CalculateDecay(float a1, float a2, float b1, float b2)
    {
      float decay = 0;
      if (b2 >= a2)
      {
        if (b1 >= a1)
        {
          //We open below
          decay = (b1 - a2) / (a1 - a2);
        }
        else
        {
          //we open to a bigger place, let in all the light
          decay = (a1 - a2) / (a1 - a2); // 100% 
        }
      }
      else
      {
        if (b1 >= a1)
        {
          //We open into a smaller cave, decay a lot
          decay = (b1 - b2) / (a1 - a2);
        }
        else
        {
          //We open above
          decay = (a1 - b2) / (a1 - a2);
        }
      }
      return decay;
    }
    private void Stitch(SortedDictionary<ivec2, List<Beam>> beams)
    {
      //Stitch up the beam stack (light path tunnels) for each layer for one of the 3 beam axes.
      //This stitches the WHOLE GRID
      // If you edit a single block, we can stitch just that block it would be much faster.

      int dbg_num_stitch = 0;
      System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch(); ;
      sw.Start();
      KeyValuePair<ivec2, List<Beam>>? last = null;
      int last_layer = -1;
      foreach (var kvp in beams)
      {
        //Note: iterating beams is sequential by x -> y.
        if (kvp.Key.Layer != last_layer)
        {
          //We are iterating over a new layer axis.
          last_layer = kvp.Key.Layer;
          last = null;
        }

        //check to see if we skipped a stack = opaque on that beam
        if (last == null || (last.Value.Key.Stack < kvp.Key.Stack - 1))
        {
          //Not set, beginning of transmission stack or
          //There was no grid data, next layer.
          last = kvp;
        }
        else if (last.Value.Key.Stack == kvp.Key.Stack - 1)
        {
          //We are a neighbor, stitch up the beams
          foreach (var beamA in last.Value.Value)
          {
            foreach (var beamB in kvp.Value)
            {
              //face value for a beam starts at the first face within the drome
              //so (x, for example)
              //                            ^ Light ray
              //| |------------>| |---------|------->| |
              //  ^ beam Face   ^ next block face   ^ and so on
              //^ block start
              if ((beamA.max < beamB.min) || (beamA.min > beamB.max))
              {
                //no hit
              }
              else
              {
                if (beamA.next == null)
                {
                  beamA.next = new List<Beam>();
                }
                if (beamB.prev == null)
                {
                  //prev is used to reverse iterate
                  beamB.prev = new List<Beam>();
                }
                dbg_num_stitch++;
                //Circular dependnecy, weak ref to let it die
                beamA.next.Add(beamB);
                beamB.prev.Add(beamA);
              }

            }
          }

          //Set us to last.
          last = kvp;

        }



      }//for
      sw.Stop();
      var x = sw.ElapsedMilliseconds;
      int n = 0;
      n++;
    }
    private void BuildAxis(World w, Drome d, SortedDictionary<ivec2, List<Beam>> beams, int[] idx)
    {
      //Beams must only be air. Min / Max must be air blocks.
      //Go through air blocks until we hit solid, that is a beam, then skip solid, air again, start new beam.
      int[] max = new int[] {
        (idx[0] == 0) ? World.DromeBlocksX : ((idx[0] == 1) ? World.DromeBlocksY : World.DromeBlocksZ),
        (idx[1] == 0) ? World.DromeBlocksX : ((idx[1] == 1) ? World.DromeBlocksY : World.DromeBlocksZ),
        (idx[2] == 0) ? World.DromeBlocksX : ((idx[2] == 1) ? World.DromeBlocksY : World.DromeBlocksZ),
      };

      for (int layerIdx = 0; layerIdx < max[2]; layerIdx++)//Integral axis int(0,x) dx
      {
        for (int stackIdx = 0; stackIdx < max[1]; stackIdx++)//Transmission axis
        {
          ivec2 v = new ivec2(stackIdx, layerIdx);

          List<Beam> beamlist = null;
          Beam curBeam = null;
          for (int beamIdx = 0; beamIdx < max[0]; beamIdx++)
          {
            int b_x = (idx[0] == 0) ? beamIdx : ((idx[0] == 1) ? stackIdx : layerIdx);//xi
            int b_y = (idx[1] == 0) ? beamIdx : ((idx[1] == 1) ? stackIdx : layerIdx);//yi
            int b_z = (idx[2] == 0) ? beamIdx : ((idx[2] == 1) ? stackIdx : layerIdx);//zi

            ushort b = d.GetBlock(b_x, b_y, b_z);
            var b_code = Block.GetVisibleBlockCode(b);
            BlockTile bt = null;
            w.BlockTiles.TryGetValue(b_code, out bt);
            //We are solid block, end beam, or we are plant, or something else semi-transparent.
            if ((b_code == BlockItemCode.Air) || ((bt != null) && (bt.Opacity <= 0.9f)))
            {
              if (beamlist == null)
              {
                beamlist = new List<Beam>();
                beams.Add(v, beamlist);
              }

              if (curBeam == null)
              {
                curBeam = new Beam();
                curBeam.min = (short)beamIdx;
                curBeam.occlusion = 0;
              }
              curBeam.occlusion += bt != null ? bt.Opacity : 0; //Could be a plant
            }
            else
            {
              //Solid block. End beam if started
              if (curBeam != null)
              {
                curBeam.max = (short)(beamIdx - 1); //the -1 is because this is solid, beams can only go from air->air
                beamlist.Add(curBeam);
                Gu.Assert(curBeam.max >= curBeam.min);//max equal min = 1 block
                curBeam = null;
              }
            }



          }//for

          if (curBeam != null)
          {
            //**TODO: Transmit beam information from neighbor glob .. 
            curBeam.max = (short)(max[0] - 1);
            beamlist.Add(curBeam);
            Gu.Assert(curBeam.max >= curBeam.min);
          }
          curBeam = null;
          beamlist = null;
        }//for 
      }//for 

    }
    #endregion

  }
    //I think we can simplify the beam greid
  // SO inestead of 3 axes just 1 axis - y - y beams 
  //so take the light ray and just go through each beam
  //light travels in all directions on the cube
  public class Beam
  {
    //Beam me up!
    public Beam() { }
    public short min = 0; // local block position in drome, min x,y ,z
    public short max = 0;
    public float occlusion = 0; //amount of occlusion between blocks
    public vec3 color_min = vec3.Zero;  // light multiplied by color
    public vec3 color_max = vec3.Zero;
    public float light_min = 0; //the computed light intensity
    public float light_max = 0;
    public List<Beam> next = null;//next beam in the stack
    public List<Beam> prev = null;
  }



public class Drome : DromeNode
  // {
  //   //Density / Block units / BVH Root

  //   //public BeamGrid2 BeamGrid2 = null;
  //   //public Grid3D<GRay> LightGrid = null;
  //   public Grid3D<ushort> Blocks = new Grid3D<ushort>(World.DromeBlocksX, World.DromeBlocksY, World.DromeBlocksZ);

  //   public int _lock = 0;
  //   public bool Locked { get { return _lock > 0; } }
  //   public void Lock() { _lock++; }
  //   public void Unlock() { _lock--; }

  //   private WeakReference<World> _world = null;
  //   public BlockStats BlockStats = new BlockStats();
  //   public RegionBlocks[] GlobRegionStates = null;
  //   public ivec3 Pos = new ivec3(0, 0, 0);
  //   public GenState GenState = GenState.Created; //Note C# integral types are atomic.
  //   public static DromeNode Static_Hierarchy = null;

  //   public vec3 OriginR3
  //   {
  //     get
  //     {
  //       vec3 r = new vec3(
  //         (float)Pos.x * World.DromeWidthX,
  //         (float)Pos.y * World.DromeWidthY,
  //         (float)Pos.z * World.DromeWidthZ);
  //       return r;
  //     }
  //   }
  //   public vec3 CenterR3
  //   {
  //     get
  //     {
  //       return OriginR3 + new vec3(World.DromeWidthX * 0.5f,
  //                                  World.DromeWidthY * 0.5f,
  //                                  World.DromeWidthZ * 0.5f);
  //     }
  //   }
  //   public int dbg_nCount_Empty_Leaves = 0;
  //   public int dbg_nCountLeaves = 0;
  //   public int dbg_nCountProcessed_Children = 0;
  //   public int dbg_nCountCulled = 0;
  //   public int dbg_nCountHave = 0;

  //   public static Box3f GetDromeBox(ivec3 pos)
  //   {
  //     return new Box3f(
  //       new vec3(
  //         pos.x * World.DromeWidthX,
  //         pos.y * World.DromeWidthY,
  //         pos.z * World.DromeWidthZ),
  //       new vec3(
  //         (pos.x + 1) * World.DromeWidthX,
  //         (pos.y + 1) * World.DromeWidthY,
  //         (pos.z + 1) * World.DromeWidthZ
  //       )
  //       );
  //   }
  //   public Drome(World w, ivec3 pos, Int64 genframeStamp)
  //   {
  //     Pos = pos;
  //     _world = new WeakReference<World>(w);

  //     _box = GetDromeBox(pos);

  //     if (Static_Hierarchy == null)
  //     {
  //       Static_Hierarchy = new DromeNode();
  //       Static_Hierarchy.Subdivide_Static_Hierarchy(true);
  //     }
  //   }
  //   public RegionBlocks GetRegionStateForDromeNodeLeaf(DromeNode d)
  //   {
  //     //We do not have any region states if we are an empty Drome.
  //     //REturn the default "none" to signal to the system that we can cull everything.
  //     if (GlobRegionStates == null)
  //     {
  //       return RegionBlocks.EmptyRegionState_Glob;
  //     }
  //     vec3 c = d.Box._min + (d.Box._max - d.Box._min) * 0.5f;
  //     ivec3 gpos_global = World.R3toI3Glob(c);
  //     ivec3 gpos_local = World.GlobGlobal_Z3_To_DromeLocal_Z3(gpos_global);
  //     //we are a glob
  //     var off = Drome.RegionStateOffset_FromLocalGlobPos(gpos_local);
  //     Gu.Assert(off < Drome.DromeRegionStateCount);
  //     var rs = GlobRegionStates[off];
  //     return rs;
  //   }
  //   public static int BlockOffset(ivec3 local_block_pos_in_drome)
  //   {
  //     int ret = World.DromeBlocksX * World.DromeBlocksY * local_block_pos_in_drome.z +
  //       World.DromeBlocksX * local_block_pos_in_drome.y +
  //       local_block_pos_in_drome.x;
  //     return ret;
  //   }
  //   public static int BlockOffset(int local_x, int local_y, int local_z)
  //   {
  //     int ret = World.DromeBlocksX * World.DromeBlocksY * local_z +
  //       World.DromeBlocksX * local_y +
  //       local_x;
  //     return ret;
  //   }
  //   public static int RegionStateOffset_FromLocalBlockPos(ivec3 local_block_pos_in_drome)
  //   {
  //     int dx = local_block_pos_in_drome.x / World.GlobBlocksX;
  //     int dy = local_block_pos_in_drome.y / World.GlobBlocksY;
  //     int dz = local_block_pos_in_drome.z / World.GlobBlocksZ;
  //     int ret = World.DromeGlobsX * World.DromeGlobsY * dz + World.DromeGlobsX * dy + dx;
  //     return ret;
  //   }
  //   public static int RegionStateOffset_FromLocalGlobPos(ivec3 local_glob_pos_in_drome)
  //   {
  //     int dx = local_glob_pos_in_drome.x;
  //     int dy = local_glob_pos_in_drome.y;
  //     int dz = local_glob_pos_in_drome.z;
  //     int ret = World.DromeGlobsX * World.DromeGlobsY * dz + World.DromeGlobsX * dy + dx;
  //     return ret;
  //   }
  //   public static ivec3 R3toI3BlockLocal_Drome(vec3 R3)
  //   {
  //     ivec3 bpos = World.R3ToI3BlockLocal_Any(R3, World.DromeWidthX, World.DromeWidthY, World.DromeWidthZ);
  //     if (bpos.x < 0 || bpos.y < 0 || bpos.z < 0 || bpos.x >= World.DromeBlocksX || bpos.y >= World.DromeBlocksY || bpos.z >= World.DromeBlocksZ)
  //     {
  //       Gu.DebugBreak();
  //     }
  //     return bpos;
  //   }
  //   public void Create_or_UpdateGlobForModifiedBlock(ModifiedBlock mb)
  //   {
  //     if (_world.TryGetTarget(out var w))
  //     {
  //       //Basically what this does is we drill down to the glob that was modified and create it.
  //       //Then, the visibility update should catch the new glob and generate it.
  //       DoLiterallyEverything(w, this, w.Camera, null, mb);
  //       //**TODO: subdivide neighbors as as well when this block borders other globs.
  //     }
  //   }
  //   public void DeleteGlobForModifiedBlock(ModifiedBlock mb)
  //   {
  //     if (_world.TryGetTarget(out var w))
  //     {
  //       //Same as above - we do a subdivision again. When we drill down to the given point, we'll determine if the glob is visible, or not.
  //       //if it's not, it will get deleted automatically.
  //       DoLiterallyEverything(w, this, w.Camera, null, mb);
  //       //**TODO: subdivide neighbors as as well when this block borders other globs.
  //     }
  //   }
  //   public const ushort InitialBlockValue = BlockItemCode.Air;
  //   public const int DromeBlockCount = World.DromeBlocksX * World.DromeBlocksY * World.DromeBlocksZ;
  //   public const int DromeRegionStateCount = World.DromeGlobsX * World.DromeGlobsY * World.DromeGlobsZ;
  //   public void AllocateBlocks()
  //   {
  //     Blocks.Allocate(Drome.InitialBlockValue);
  //   }
  //   public void AllocateRegionStates()
  //   {
  //     GlobRegionStates = new RegionBlocks[Drome.DromeRegionStateCount];
  //     //foreach(var g in GlobRegionStates)
  //     for (int i = 0; i < GlobRegionStates.Length; i++)
  //     {
  //       GlobRegionStates[i].Init();
  //     }
  //   }
  //   public bool HasBlockData()
  //   {
  //     return Blocks.Grid != null;
  //   }
  //   public void SetBlock(ivec3 local_block_pos_in_drome, ushort block_solidcode_liquid_or_both, bool bInitialGen_Dont_DivideGlob, BlockBits bits)
  //   {
  //     //Sets the actual block data code - does not account for what is in the block i.e. solid/liquid.. sets the whole code
  //     //dontdivideglob - if this is false then we won't run the division routine to create a BVH, and queue affected nodes for update, set InitialGen to true when mining blocks 

  //     //We may be empty, in which case we need to reallocate our data.
  //     if (!HasBlockData())
  //     {
  //       //We cull blocks from empty globs to save memory.
  //       AllocateBlocks();
  //       AllocateRegionStates();
  //     }

  //     ushort old = GetBlock(local_block_pos_in_drome);
  //     // ushort old_solid = Block.GetSolid(old);
  //     // ushort old_liquid = Block.GetLiquid(old);

  //     ushort block = old;
  //     Block.SetBlock(ref block, block_solidcode_liquid_or_both, bits);

  //     if (bits == BlockBits.Liquid)
  //     {
  //       int n = 0;
  //       n++;
  //     }

  //     Blocks.Set(local_block_pos_in_drome, block);

  //     //See comments on drome.
  //     BlockStats.UpdateBlockModified(old, block);
  //     GlobRegionStates[Drome.RegionStateOffset_FromLocalBlockPos(local_block_pos_in_drome)].UpdateBlockModified(old, block);

  //     if (!bInitialGen_Dont_DivideGlob)
  //     {

  //       int region_off = Drome.RegionStateOffset_FromLocalBlockPos(local_block_pos_in_drome);

  //       bool solid_before = GlobRegionStates[region_off].HasValues;
  //       bool empty_before = GlobRegionStates[region_off].IsEmpty;

  //       GlobRegionStates[region_off].UpdateBlockModified(old, block);

  //       bool solid_after = GlobRegionStates[region_off].HasValues;
  //       bool empty_after = GlobRegionStates[region_off].IsEmpty;

  //       vec3 block_pos_r3 = OriginR3 + new vec3(
  //           (float)local_block_pos_in_drome.x * World.BlockSizeX,
  //           (float)local_block_pos_in_drome.y * World.BlockSizeY,
  //           (float)local_block_pos_in_drome.z * World.BlockSizeZ
  //           );

  //       ModifiedBlock mb = new ModifiedBlock(block_pos_r3, old, block);
  //       if (!empty_before && empty_after)
  //       {
  //         DeleteGlobForModifiedBlock(mb);
  //       }
  //       else
  //       {
  //         //we are solid
  //         Create_or_UpdateGlobForModifiedBlock(mb);
  //       }

  //     }
  //   }
  //   public ushort GetBlock(ivec3 local_pos_drome, IndexMode im = IndexMode.Throw)
  //   {
  //     //If we are empty, then we have deleted our Block[] data to save space. Return an empty block
  //     if (BlockStats.RegionState == RegionState.Empty_AndNoData)
  //     {
  //       return BlockItemCode.Air;
  //     }
  //     var b = Blocks.Get(local_pos_drome, im);
  //     return b;
  //   }
  //   public ushort GetBlock(int local_x, int local_y, int local_z)
  //   {
  //     //If we are empty, then we have deleted our Block[] data to save space. Return an empty block
  //     if (BlockStats.RegionState == RegionState.Empty_AndNoData)
  //     {
  //       return BlockItemCode.Air;
  //     }
  //     return Blocks.Get(local_x, local_y, local_z, IndexMode.Throw);
  //   }
  //   public void SetBlock(vec3 pos_r3, ushort solid_liquid_both, BlockBits bits)
  //   {
  //     ivec3 b_pos = R3toI3BlockLocal_Drome(pos_r3);
  //     SetBlock(b_pos, solid_liquid_both, false, bits);
  //   }


  // }//class Drome


    public class DromeKernel : List<Drome>
  {
    //Asynchronous generation for globs (mesh topologies within the drome)

    private const int C27_Count = 27;
    public DromeKernel()
    {
      for (int i = 0; i < C27_Count; ++i)
      {
        Add(null);
      }
    }
    public void Set(int ddx, int ddy, int ddz, Drome d)
    {
      this[9 * ddz + 3 * ddy + ddx] = d;
    }
    public Drome Get(int ddx, int ddy, int ddz)
    {
      return this[9 * ddz + 3 * ddy + ddx];
    }
    public Drome Get(ivec3 idx)
    {
      return Get(idx.x, idx.y, idx.z);
    }
    public void Lock()
    {
      //Unlock our boys
      foreach (var d in this)
      {
        if (d != null)
        {
          d.Lock();
        }
      }
    }
    public void Unlock()
    {
      //Unlock our boys
      foreach (var d in this)
      {
        if (d != null)
        {
          d.Unlock();
        }
      }
    }
  }


  public class QueuedGlobData_WithKernel
  {
    //public Drome drome;//keep this here to prevent drome from disappearing while iterating its blocks ** this willb e in locked droems
    public Glob MyGlob;
    //C27
    //                  24 25 26
    //         15 16 17 21 22 23
    //06 07 08 12 13 14 18 19 20
    //03 04 05 09 10 11 
    //00 01 02
    // x-->  ^y /z  Center (our drome) = 13

    public DromeKernel ScalarFields = new DromeKernel();
    public List<v_v3n3x2u1> async_verts = null;
    public List<VisibleBlockFaceData> async_face_data = null;
    public List<ushort> async_inds_op = null;
    public List<ushort> async_inds_tp = null;
    public Dictionary<BlockItem, List<vec3>> async_block_items = null;
    public List<vec3> async_colors = null;

    public double DistanceToPlayer = 0;//Sort key for generating
    public ushort[] CopiedBlocks = null;//Note this is the block kernel of blocks + n

    public void CreateBuffers()
    {
      if (async_verts == null)
      {
        async_verts = new List<v_v3n3x2u1>();
      }
      if (async_inds_op == null)
      {
        async_inds_op = new List<ushort>();
      }
      if (async_inds_tp == null)
      {
        async_inds_tp = new List<ushort>();
      }
      if (async_face_data == null)
      {
        async_face_data = new List<VisibleBlockFaceData>();
      }
      if (async_colors == null)
      {
        async_colors = new List<vec3>();
      }
    }
    public void ReleaseBuffers()
    {
      async_verts?.Clear();
      async_verts = null;
      async_inds_op?.Clear();
      async_inds_op = null;
      async_inds_tp?.Clear();
      async_inds_tp = null;
      //async_face_data?.Clear(); //Note: Since we directly copy this stuff, it's not wise to clear it .. just in case we didn't set it to null
      //async_face_data = null;
      //async_block_items?.Clear();
      //async_block_items = null;
      async_colors?.Clear();
      async_colors = null;
    }
    public static int Kernel_Offset(int dx, int dy, int dz)
    {
      int off = World.GlobBlocksX_Gen_Kernel * World.GlobBlocksY_Gen_Kernel * dz +
                World.GlobBlocksX_Gen_Kernel * dy +
                dx;
      return off;
    }
    public ushort GetBlock_Kernel(int dx, int dy, int dz)
    {
      Gu.Assert(dx >= 0 && dx < World.GlobBlocksX_Gen_Kernel);
      Gu.Assert(dy >= 0 && dy < World.GlobBlocksY_Gen_Kernel);
      Gu.Assert(dz >= 0 && dz < World.GlobBlocksZ_Gen_Kernel);
      //If we are empty, then we have deleted our Block[] data to save space. Return an empty block
      int off = Kernel_Offset(dx, dy, dz);

      return CopiedBlocks[off];
    }
    public ushort GetBlock_Glob_Drome(int dx, int dy, int dz)
    {
      //I am no longer using "Missing" in the assumption this will work.
      ivec3 glocal = World.GlobGlobal_Z3_To_DromeLocal_Z3(MyGlob.Pos);

      ivec3 c27_drome_idx = new ivec3(1, 1, 1);

      int x = glocal.x * World.GlobBlocksX + dx;
      int y = glocal.y * World.GlobBlocksY + dy;
      int z = glocal.z * World.GlobBlocksZ + dz;

      //Wrap
      if (x < 0)
      {
        x = (x % World.DromeBlocksX) + World.DromeBlocksX;
        c27_drome_idx.x -= 1;
      }
      else if (x >= World.DromeBlocksX)
      {
        x = (x % World.DromeBlocksX);
        c27_drome_idx.x += 1;
      }
      if (y < 0)
      {
        y = (y % World.DromeBlocksY) + World.DromeBlocksY;
        c27_drome_idx.y -= 1;
      }
      else if (y >= World.DromeBlocksY)
      {
        y = (y % World.DromeBlocksY);
        c27_drome_idx.y += 1;
      }
      if (z < 0)
      {
        z = (z % World.DromeBlocksZ) + World.DromeBlocksZ;
        c27_drome_idx.z -= 1;
      }
      else if (z >= World.DromeBlocksZ)
      {
        z = (z % World.DromeBlocksZ);
        c27_drome_idx.z += 1;
      }

      var d = ScalarFields.Get(c27_drome_idx);

      Gu.Assert(d != null);

      if (d.Blocks.Grid == null)
      {
        return BlockItemCode.Air;
      }

      return d.Blocks.Get_Direct_Unsafe_But_Fast(x, y, z);
    }
  }
  

  public class QueuedDromeData
  {
    //Asynchronous generation data for dromes (scalar fields e.g. blocks as ushort)
    public Drome drome = null;
    public ivec3 gpos;
    public double DistanceToPlayer = 0;
  }


    // public class ChunkStats
  // {
  //   public int LeafCount = 0;
  // }
  // public class ChunkRoot : ChunkNode
  // {
  //   public ChunkStats Stats { get; private set; } = new ChunkStats(); //root only

  //   //The number of bars per glob will depend on the WorldInfo so we cant hard code this
  //   public Int64 GeneratedFrameStamp { get; private set; } = 0;
  //   public MeshData Transparent = null;
  //   public MeshData Opaque = null;
  //   public ivec3 Pos = new ivec3(0, 0, 0);
  //   private World _world = null;

  //   public ChunkRoot()
  //   {
  //   }
  // }
  // public class ChunkLeaf : ChunkNode
  // {
  //   public List<Beam> Beams;
  // }
  // public class ChunkNode
  // {
  //   public ChunkNode[] Children = null; //octree .. 
  //   private bool[] ChildWasProcessed = new bool[8] { false, false, false, false, false, false, false, false }; //this could be just a byte but man it sucks doing bit shit in c number
  //   protected Box3f _box;
  //   public bool IsStaticHierarchy = false; //Static leaf box block
  //   public bool IsDirty = true;
  //   public long LastVisible_ms = 0; //Last time this glob was visible.
  //   public bool IsLeaf { get { return this is ChunkLeaf; } }
  //   public bool IsRoot { get { return this is ChunkRoot; } }

  //   public static bool IsVisible(World w, Camera3D cam, Box3f box)
  //   {
  //     float dist_cam2 = box.DistanceToCam2(cam.Position_World);
  //     bool vis = cam.Frustum.HasBox(box) && (dist_cam2 < (w.RenderDistance * w.RenderDistance));
  //     return vis;
  //   }
  //   public Box3f Box
  //   {
  //     get
  //     {
  //       return _box;
  //     }
  //   }
  //   public vec3 OriginR3 { get { return _box._min; } }
  //   // public void Subdivide_Static_Hierarchy(bool isroot)
  //   // {
  //   //   IsStaticHierarchy = true;

  //   //   //treat this as a static glob that we subdivide until we hit blocks. This is used for raycasting.
  //   //   if (isroot)
  //   //   {
  //   //     _box = new Box3f(new vec3(0, 0, 0), new vec3(World.GlobWidthX, World.GlobWidthY, World.GlobWidthZ));
  //   //   }

  //   //   if ((Box.Width() < World.BlockSizeX + 0.01f) &&
  //   //     (Box.Height() < World.BlockSizeY + 0.01f) &&
  //   //     (Box.Depth() < World.BlockSizeZ + 0.01f))
  //   //   {
  //   //     IsLeaf = true;
  //   //   }
  //   //   else
  //   //   {
  //   //     Children = new ChunkNode[8];
  //   //     Box3f[] cbox = Box.Divide();
  //   //     for (int ci = 0; ci < 8; ci++)
  //   //     {
  //   //       Children[ci] = new ChunkNode();
  //   //       Children[ci]._box = cbox[ci];
  //   //       Children[ci].Subdivide_Static_Hierarchy(false);
  //   //     }
  //   //   }
  //   // }
  //   private static bool CheckLeaf(WorldInfo info, ChunkRoot root, Box3f box)
  //   {
  //     //check if leaf
  //     //also check region state if we are. 
  //     if (
  //         (box.Width() < info.GlobWidthX + 0.01f) &&
  //         (box.Height() < info.GlobWidthY + 0.01f) &&
  //         (box.Depth() < info.GlobWidthZ + 0.01f))
  //     {
  //       return true;
  //       //So, we either did, or didn't divide the child.

  //       // var state = root.GetRegionStateForDromeNodeLeaf(this);
  //       // if (state.IsEmpty /*|| rs.IsSolid*/)//.. ?Makes no sesne for solid as cubers generate their own topology.
  //       // {
  //       //   root.dbg_nCount_Empty_Leaves++;

  //       //   return 8; //Parent culls any nodes that return 8.
  //       // }
  //     }
  //     return false;
  //   }

  //   public int DoLiterallyEverything(World w, ChunkRoot root, Camera3D cam, BlockWorldVisibleStuff stuff = null, ModifiedBlock mb = null)
  //   {
  //     //What this does:
  //     // subdivide drome into node hierarchy
  //     // create globs (world meshes)
  //     // edit globs
  //     // delete globs
  //     // delete node hierarchy
  //     // collect visible objects visible globs for render

  //     Gu.Assert((w != null) && (root != null) && (cam != null));

  //     int nculled = 0;

  //     //return the number of children that are empty or, have no topology
  //     Gu.Assert(root != null);

  //     LastVisible_ms = Gu.Milliseconds();

  //     if (IsLeaf)
  //     {
  //       //Note - We already checked for region state when CREATING this leaf - so if we get here
  //       //it means we have a non-empty region state and this leaf does have visible data. (however we dont' check for world objects here)
  //       // if ((mb != null) || (Glob == null))
  //       // {
  //       //   vec3 box_center = _box.center();
  //       //   ivec3 gpos = World.R3toI3Glob(box_center);
  //       //   Glob = w.QueueGlob(Glob, root, gpos);
  //       // }
  //       // else if ((Glob != null) && (Glob.State == GenState.Ready) && (stuff != null))
  //       // {
  //       //   //We have a glob and we are collecting stuff to render
  //       //   stuff.Collect(cam, Glob, this);
  //       // }

  //       return 0;
  //     }
  //     else
  //     {
  //       //Create or recreate missing children
  //       for (int ci = 0; ci < 8; ci++)
  //       {
  //         var box = ((Children != null) && (Children[ci] != null)) ? Children[ci].Box : Box.GetDivisionChild(ci);

  //         //Check if we must go on
  //         bool must_process_child = false;
  //         if (mb == null)
  //         {
  //           //visible
  //           if (ChunkNode.IsVisible(w, cam, box))
  //           {
  //             must_process_child = true;
  //           }
  //         }
  //         else if (mb != null)
  //         {
  //           //dividing by a modified block / point. Node may not be visible but we still divide.
  //           if (Children != null && Children[ci] != null)
  //           {
  //             must_process_child = box.containsPointBottomLeftInclusive(mb.Pos);
  //           }
  //           else
  //           {
  //             must_process_child = box.containsPointBottomLeftInclusive(mb.Pos);
  //           }
  //         }

  //         if (must_process_child)
  //         {
  //           ChildWasProcessed[ci] = true;

  //           if (Children == null)
  //           {
  //             Children = new ChunkNode[8] { null, null, null, null, null, null, null, null };
  //           }

  //           int num_culled_child = 0;

  //           if (Children[ci] == null)
  //           {
  //             //num_culled_child = 
  //             if (CheckLeaf(w.Info, root, box))
  //             {
  //               Children[ci] = new ChunkLeaf();
  //             }
  //             else
  //             {
  //               Children[ci] = new ChunkNode();
  //             }

  //             Children[ci]._box = Box.GetDivisionChild(ci);
  //             //** Check the region state, exit if it is empty
  //             if (num_culled_child == 8)
  //             {
  //               Children[ci] = null;
  //             }
  //           }

  //           if (Children[ci] != null)
  //           {
  //             num_culled_child = Children[ci].DoLiterallyEverything(w, root, cam, stuff, mb);
  //           }

  //           //cull empty child
  //           if (num_culled_child == 8)
  //           {
  //             Children[ci] = null;
  //             root.dbg_nCountCulled++;
  //           }
  //         }

  //         if (Children == null || Children[ci] == null)
  //         {
  //           nculled++;
  //         }
  //       }

  //       //We culled all the kids - set children to  null. and get ourselves culled.
  //       if (nculled == 8)
  //       {
  //         Children = null;
  //       }
  //     }

  //     //Delete check.. Make sure the Gen  < delete distance or we gen/delete over and over..
  //     if (w.Drome_or_Node_Can_Delete_Distance(_box) && ((Gu.Milliseconds() - LastVisible_ms) > World.Abandon_DeleteTime_DromeNode_ms))
  //     {
  //       //Delete if we are invisible
  //       nculled = 8;
  //     }
  //     if (this == root)
  //     {
  //       //Do not cull dromes here. We cull them outside here
  //       nculled = 0;
  //     }

  //     return nculled;
  //   }
  // }




    // public Beam GetBeamForPoint_BottomLeftInclusive_WithCaps(vec3 pt)
    // {
    //   //Check that a point intersects a beam base mesh volume exactly (including triangles)
    //   Beam ret = null;
    //   vec3 pt_rel = pt - this.OriginR3;
    //   int x = (int)(pt_rel.x / _world.Info.GlobBlocksX);
    //   int z = (int)(pt_rel.z / _world.Info.GlobBlocksZ);
    //   BeamList bl = BeamGrid.Get(x, z, IndexMode.Throw);
    //   if (bl != null)
    //   {
    //     ushort h = _world.Info.ConvertHeight(pt.y);
    //     List<Beam> beams = bl.GetBeamsForHeight(h);
    //     if (beams != null)
    //     {
    //       Gu.Assert(beams.Length > 0);

    //       if (beams[0] != null && beams[1] != null)
    //       {
    //         if (_world.Info.Beam_Contains_Point_Global_Bottom_Left_Inclusive_WITHCaps(x, z, pt, beams[0], this.OriginR3))
    //         {
    //           ret = beams[0];
    //         }
    //         else
    //         {
    //           ret = beams[1];
    //         }
    //       }
    //       else if (beams[0] != null)
    //       {
    //         ret = beams[0];
    //       }
    //       else
    //       {
    //         Gu.Trap();
    //       }
    //     }
    //   }
    //   return ret;
    // }


    // public void AddManualResources()
    // {
    //   AddGLTFResource(ResourceID.Model_Camera, "camera.glb", FileStorage.Embedded);
    //   AddGLTFResource(ResourceID.Model_Gear, "gear.glb", FileStorage.Embedded);
    // }
    // public void AddGLTFResource(ResourceID id, string file, FileStorage storage)
    // {
    //   AddResource(new ResourceNode(ResourceType.GLTFFile, id, new List<FileLoc> { new FileLoc(file, storage) }));
    // }
    // private bool TryGetDefinedResource(ResourceDescriptor rscid, DataSource input_source, out ResourceNode? outrsc)
    // {
    //   var ret = false;
    //   var rscByID = GetResourceById(rscid.UniqueID);
    //   // var rscByName = GetResourceByName(rt, rscid.Description());

    //   outrsc = rscByID;

    //   //Check for data coherency
    //   // if ((rscByID == null && rscByName != null) || (rscByID != null && rscByName == null))
    //   // {
    //   //   if (rscByName != null)
    //   //   {
    //   //     outrsc = rscByName;
    //   //   }
    //   //   Gu.DebugBreak();//uh..problem
    //   // }

    //   if (outrsc == null)
    //   {
    //     //either the resource wasn't defined, or it was defined but the parameters were different
    //     ret = true;
    //   }
    //   else
    //   {
    //     //load ahd check resource for parameter changes
    //     var rsc = LoadResource(outrsc);
    //     var existing_source = rsc as DataSource;
    //     if (!existing_source.CheckParams(input_source))
    //     {
    //       DeleteResource(outrsc);
    //     }
    //     TryUnloadResource(outrsc);

    //     Gu.Log.Info($"Already defined resource id={rscid.ToString()}.");
    //     ret = false;
    //   }
    //   return ret;
    // }
    // private T? DefineResource<T>(DataSource dataSource) where T : DataBlock
    // {
    //   //define but don't load the object.
    //   T? outobj = null;
    //   DefineResource<T>(out outobj, dataSource);
    //   return outobj;
    // }
    // private bool DefineResource<T>(out T? outobj, DataSource dataSource) where T : DataBlock
    // {
    //   //Define new resource (possibly, embedded), returnign the loaded / parsed resource to be processed
    //   //Return true if we are returning a newly loaded / defined model.
    //   //this happens if either 
    //   // A) loader parameters change 
    //   // B) the model has not been defined yet
    //   // C) Something else changed, like ID, or Name (which is an error)
    //   Gu.Assert(dataSource != null);
    //   Gu.Assert(dataSource.Descriptor != null);
    //   outobj = null;
    //   var ret = false;
    //   if (!TryGetDefinedResource(dataSource.Descriptor, dataSource, out var rsc))
    //   {
    //     outobj = (T?)dataSource.Create();
    //     Gu.Assert(outobj != null);

    //     if (rsc != null)
    //     {
    //       outobj.ChangeResource(rsc);
    //     }
    //     ret = true;
    //   }
    //   return ret;
    // }

    //OBJ return Defines
    // public bool DefineModel(GLTFFile m, out WorldObject? outobj)
    // {
    //   return DefineResource<WorldObject>(out outobj, m);
    // }
    // public bool DefineShader(ShaderLoader m, out Shader? outobj)
    // {
    //   return DefineResource<Shader>(out outobj, m);
    // }
    // public bool DefineImage(Img32Generator m, out Img32? outobj)
    // {
    //   return DefineResource<Img32>(out outobj, m);
    // }
    // public bool DefineImage(global::Img32Generator m, out Img32? outobj)
    // {
    //   return DefineResource<Img32>(out outobj, m);
    // }
    // public bool DefineMaterial(global::Img32Generator m, out Img32? outobj)
    // {
    //   return DefineResource<Img32>(out outobj, m);
    // }
    // //Objless defines
    // public WorldObject? DefineModel(GLTFFile m)
    // {
    //   return DefineResource<WorldObject>(m);
    // }
    // public Shader? DefineShader(ShaderLoader m)
    // {
    //   return DefineResource<Shader>(m);
    // }
    // public Img32? DefineImage(Img32Generator m)
    // {
    //   return DefineResource<Img32>(m);
    // }
    // public Img32? DefineImage(global::Img32Generator m)
    // {
    //   return DefineResource<Img32>(m);
    // }

    //just one function "make" then call Load() to load it. otherwise we just define it
    //Gu.Lib.MakeShader().Load()
    //Make will define something, then call Load() to load it.
    //Pass ResourceID to create the resource with the given ID
    // public Shader? MakeShader(string resource_name, string shader_generic_name, bool hasGS, FileStorage storage, OpenTK.Graphics.OpenGL4.PrimitiveType? gsPrimType = null)
    // {
    //   return MakeShader(new ResourceDescriptor(ResourceType.Shader, resource_name, Lib.NullID, ResourceDescriptor.ResourceCreateFlags.CreateNew, ResourceDescriptor.ResourceLoadFlags.DoNotLoad),
    //     shader_generic_name, hasGS, storage, gsPrimType);
    // }
    // public Shader? MakeShader(ResourceDescriptor name, string shader_generic_name, bool hasGS, FileStorage storage, OpenTK.Graphics.OpenGL4.PrimitiveType? gsPrimType = null)
    // {
    //   //Create a new shader, do not load it yet
    //   ShaderLoader sl = new ShaderLoader(name, shader_generic_name, hasGS, storage, gsPrimType);
    //   DefineResource<Shader>(out var outobj, sl);
    //   Shader? s = sl.Create<Shader>();
    //   return s;
    // }
    // public Texture2D? MakeTexture2D(ResourceDescriptor resource_name, FileLoc loc, bool mipmaps, TexFilter filter, TextureWrapMode wrap = TextureWrapMode.Repeat)
    // {
    //   Img32Loader il = new Img32Loader(resource_name, loc);
    //   var img = il.Create<Img32>();
    //   var tex = new Texture2D(resource_name, img, mipmaps, filter, wrap);
    //   return tex;
    // }
    // public Material MakeShader(string resource_name, Shader s, PBRTextureArray textures)
    // {
    //   var mat = new Material(resource_name, s, textures);
    //   return mat;
    // }
  public class DataPathSuffix : Attribute
  {
    public string Suffix = Lib.UnsetName;
    public DataPathSuffix(string suf)
    {
      Suffix = suf;
    }
  }

    public enum ResourceContext
  {
    Global = 100,
    Local = 200,
  }

  // public enum ResourceProperty
  // {
  //   [TypeAttribute(typeof(FileLoc))] FileLoc,
  //   [TypeAttribute(typeof(String))] GenericName,
  //   [TypeAttribute(typeof(System.Boolean))] FlipTris,
  //   [TypeAttribute(typeof(System.Boolean))] ShaderHasGS,
  //   [TypeAttribute(typeof(FileStorage))] FileStorage,
  //   [TypeAttribute(typeof(PrimitiveType))] ShaderPrimitiveType,
  // }
  // public class ResourcePropertyTable : ISerializeBinary
  // {
  //   public Dictionary<ResourceProperty, string> _dict = new Dictionary<ResourceProperty, string>();
  //   //Generally speaking, this table is the list of parameters to the resource create function. And anything else needed to create it.
  //   public void Set(ResourceProperty key, System.String val)
  //   {
  //     Set(key, val.ToString(), val.GetType());
  //   }
  //   public void Set(ResourceProperty key, System.Boolean val)
  //   {
  //     Set(key, val.ToString(), val.GetType());
  //   }
  //   public System.Boolean GetBool(ResourceProperty key)
  //   {
  //     return System.Boolean.Parse(Get(key, typeof(System.Boolean)));
  //   }
  //   public void Set(ResourceProperty key, FileLoc f)
  //   {
  //     Set(key, f.ToString(), f.GetType());
  //   }
  //   public String GetString(ResourceProperty key)
  //   {
  //     return Get(key, typeof(System.String));
  //   }
  //   public FileLoc GetFileLoc(ResourceProperty key)
  //   {
  //     return FileLoc.Parse(Get(key, typeof(FileLoc)));
  //   }

  //   public T GetEnum<T>(ResourceProperty key)
  //   {
  //     return Gu.ParseEnum<T>(Get(key, typeof(T)));
  //   }
  //   public void SetEnum<T>(ResourceProperty key, T value)
  //   {
  //     Set(key, value.ToString(), value.GetType());
  //   }

  //   private String Get(ResourceProperty key, Type valtype)
  //   {
  //     //this should throw if it fails
  //     Gu.Assert(key.GetAttribute<TypeAttribute>().Type == valtype);
  //     _dict.TryGetValue(key, out var vv);
  //     Gu.Assert(vv != null);//string can be empty, not null
  //     return vv;
  //   }
  //   private void Set(ResourceProperty key, string val, Type valtype)
  //   {
  //     Gu.Assert(key.GetAttribute<TypeAttribute>().Type == valtype);
  //     _dict.Add(key, val);
  //   }
  //   public void Serialize(BinaryWriter bw)
  //   {
  //     bw.Write(_dict.Count);
  //     foreach (var item in _dict)
  //     {
  //       bw.Write(item.Key.ToString());
  //       bw.Write(item.Value.ToString());
  //     }
  //   }
  //   public void Deserialize(BinaryReader br, SerializedFileVersion v)
  //   {
  //     Gu.BRThrowNotImplementedException();
  //   }
  // }



  // // [DataContract] [Serializable]
  // // public class ResourceNode : ISerializeBinary
  // // {
  // //   //Anything that needs to be unique must be in the resource node.


  // //   //LastModify can be a Prop it is perticular to files


  // //   public ResourceNode() { }
  // //   public ResourceNode(string name, ResourceType tt, UInt64 id)
  // //   {
  // //     Name = name;
  // //     ResType = tt;
  // //     UniqueID = id;
  // //     _lastSaveOrLoadTime = _lastSaveOrLoadTime = DateTime.Now;
  // //   }

  // //   public bool GetRef<T>(out T? outt) where T : DataBlock
  // //   {
  // //     outt = null;
  // //     if (Ref != null && Ref.TryGetTarget(out var db))
  // //     {
  // //       Gu.Assert(db != null);
  // //       Gu.Assert(db.GetType() is T);
  // //       outt = (T)db;
  // //       return true;
  // //     }
  // //     return false;
  // //   }
  // //   public void Serialize(BinaryWriter bw)
  // //   {
  // //     bw.Write(LastModifyTime);
  // //     bw.Write(ResType.ToString());
  // //     bw.Write(UniqueID);
  // //     SerializeTools.SerializeListOfStruct<UInt64>(bw, Dependencies);
  // //   }
  // //   public void Deserialize(BinaryReader br, SerializedFileVersion v)
  // //   {
  // //     Gu.BRThrowNotImplementedException();
  // //   }
  // //   public string ToString()
  // //   {
  // //     return SerializeTools.SerializeJSON(this);
  // //   }
  // // }


  // using System.ComponentModel;

// namespace PirateCraft
// {
//   [DataContract] [Serializable]
//   public class ResourceDescriptor
//   {
//     //purpose of this class is to distinguish between resources that exist, and ones that do not,
//     //when constructing resources (tex/img/model) and load or unload them when they are created.

//     //if id is zero then make a new resource

//     public enum ResourceLoadFlags
//     {
//       Load,
//       DoNotLoad
//     }
//     public static ResourceDescriptor NONE_Undefined = new ResourceDescriptor(ResourceType.Undefined, "NONE_None", 0);

//     public static ResourceDescriptor Img32_Default1x1InvalidImage_RGBA32ub = new ResourceDescriptor(ResourceType.Image, "Img32_Default1x1InvalidImage_RGBA32ub", 1);
//     public static ResourceDescriptor Img32_Default1x1ColorPixel_RGBA32ub = new ResourceDescriptor(ResourceType.Image, "Img32_Default1x1ColorPixel_RGBA32ub", 2);
//     public static ResourceDescriptor Image_Default1x1NormalPixel_RGBA32ub = new ResourceDescriptor(ResourceType.Image, "Image_Default1x1NormalPixel_RGBA32ub", 3);

//     public static ResourceDescriptor Tex2D_Default1x1ColorPixel_RGBA32ub = new ResourceDescriptor(ResourceType.Texture, "Tex2D_Default1x1ColorPixel_RGBA32ub", 1);
//     public static ResourceDescriptor Tex2D_Default1x1NormalPixel_RGBA32ub = new ResourceDescriptor(ResourceType.Texture, "Tex2D_Default1x1NormalPixel_RGBA32ub", 2);

//     public static ResourceDescriptor Material_DefaultFlatColor = new ResourceDescriptor(ResourceType.Material, "Material_DefaultFlatColor", 1);
//     public static ResourceDescriptor Material_DefaultObjectMaterial = new ResourceDescriptor(ResourceType.Material, "Material_DefaultObjectMaterial", 2);
//     public static ResourceDescriptor Material_DebugDraw_VertexNormals_FlatColor = new ResourceDescriptor(ResourceType.Material, "Material_DebugDraw_VertexNormals_FlatColor", 3);

//     public static ResourceDescriptor Shader_GuiShader = new ResourceDescriptor(ResourceType.Shader, "Shader_GuiShader", 1);

//     public static ResourceDescriptor WorldObject_Camera = new ResourceDescriptor(ResourceType.WorldObject, "WorldObject_Camera", 1);
//     public static ResourceDescriptor WorldObject_Gear = new ResourceDescriptor(ResourceType.WorldObject, "WorldObject_Gear", 2);

//     ///
//     private static List<ResourceDescriptor> _checkDebugDupes = new List<ResourceDescriptor>();

//     private string _name = Lib.UnsetName;
//     private UInt64 _uniqueID = Lib.UnsetID;
//     private ResourceLoadFlags _loadFlags = ResourceLoadFlags.DoNotLoad;

//     public string Name { get { return _name; } set { _name = value; } }
//     public UInt64 UniqueID { get { return _uniqueID; } set { _uniqueID = value; } }
//     public ResourceLoadFlags LoadFlags { get { return _loadFlags; } set { _loadFlags = value; } }

//     public ResourceDescriptor(ResourceType type, string name, UInt64 id, ResourceLoadFlags loadFlags = ResourceLoadFlags.DoNotLoad)
//     {
//       Gu.Assert(!(type != ResourceType.Undefined && id == 0));
//       foreach (var rid in _checkDebugDupes)
//       {
//         Gu.Assert(rid.Name != name, $"Duplicate default resource ID name '{name}'");
//         Gu.Assert(rid.UniqueID != id, $"Duplicate default resource ID id '{id}'");
//       }

//       _name = name;
//       _uniqueID = (ulong)(type.IDMultiplier * (ulong)id);
//       _loadFlags = loadFlags;

//       _checkDebugDupes.Add(this);
//     }
//     public override string ToString()
//     {
//       var js = SerializeTools.SerializeJSON(this);
//       return js;
//     }
//   }
//   public static class EmbeddedResources
//   {
//     //Build some manual resources.
//     public static void BuildResources()
//     {
//      // bool global_flip_tris = true;

//       //_defaultFlatColorMaterial = new Material(System.Reflection.MethodBase.GetCurrentMethod().Name, Shader.DefaultFlatColorShader());
//       //         _defaultObjectMaterial.AlbedoSlot.Texture = Texture2D.Default1x1ColorPixel_RGBA32ub(new vec4ub(255, 255, 255, 255));

// /*

// ok so

// if model name exists
//   craet new 
//   DefinEmodel
//     TryDefineModel - 

// */

//       //Camera model
//       // Gu.Lib.DefineModel(new ModelLoader(ResourceDescriptor.WorldObject_Camera, new FileLoc("camera.glb", FileStorage.Embedded), global_flip_tris));
//       // Gu.Lib.DefineShader(new ShaderLoader(ResourceDescriptor.Shader_GuiShader, "v_gui", true, FileStorage.Embedded, OpenTK.Graphics.OpenGL4.PrimitiveType.Points));
//       // Gu.Lib.DefineImage(Img32Generator.Default1x1_RGBA32ub(ResourceDescriptor.Img32_Default1x1InvalidImage_RGBA32ub, Byte.MaxValue, 0, Byte.MaxValue, Byte.MaxValue));
//       // Gu.Lib.DefineImage(Img32Generator.Default1x1_RGBA32ub(ResourceDescriptor.Img32_Default1x1ColorPixel_RGBA32ub, Byte.MaxValue, Byte.MaxValue, Byte.MaxValue, Byte.MaxValue), out var imgcolor);

//       // //Normal maps..
//       // byte nmap_zero = Byte.MaxValue / 2;//zero in normal map is .5
//       // byte nmap_one = Byte.MaxValue;
//       // if (Texture2D.NormalMapFormat == NormalMapFormat.Yup)
//       // {
//       //   if (Gu.Lib.DefineImage(Img32Generator.Default1x1_RGBA32ub(ResourceDescriptor.Image_Default1x1NormalPixel_RGBA32ub, nmap_zero, nmap_one, nmap_zero, Byte.MaxValue), out var imgyup))
//       //   {
//       //     var tex = new Texture2D(ResourceDescriptor.Tex2D_Default1x1NormalPixel_RGBA32ub.Description(), imgyup, false, TexFilter.Nearest);
//       //     tex.Save();
//       //   }
//       // }
//       // else if (Texture2D.NormalMapFormat == NormalMapFormat.Zup)
//       // {
//       //   //t = new Texture2D("default1x1-normal", Img32Generator.Default1x1_RGBA32ub("normalzup", nmap_zero, nmap_zero, nmap_one, Byte.MaxValue), false, TexFilter.Nearest);
//       //   if (Gu.Lib.DefineImage(Img32Generator.Default1x1_RGBA32ub(ResourceDescriptor.Image_Default1x1NormalPixel_RGBA32ub, nmap_zero, nmap_zero, nmap_one, Byte.MaxValue), out var imgzup))
//       //   {
//       //     var tex = new Texture2D(ResourceDescriptor.Tex2D_Default1x1NormalPixel_RGBA32ub.Description(), imgzup, false, TexFilter.Nearest);
//       //     tex.Save();
//       //   }
//       // }
//       // else
//       // {
//       //   Gu.BRThrowNotImplementedException();
//       // }

//       //DefaultFlatColor


//       // public static Texture2D Default1x1ColorPixel_RGBA32ub(vec4ub color)
//       // {
//       //   var t = _default1x1ColorPixel_RGBA32ub.Get();
//       //   if (t == null)
//       //   {
//       //     t = new Texture2D("default1x1-color", , false, TexFilter.Nearest);
//       //     _default1x1ColorPixel_RGBA32ub.Set(t);
//       //   }
//       //   return t;
//       // }
//       // public static Texture2D Default1x1NormalPixel_RGBA32ub()
//       // {
//       //   var t = _default1x1NormalPixel_RGBA32ub.Get();
//       //   if (t == null)
//       //   {
//       //     byte nmap_zero = Byte.MaxValue / 2;//zero in normal map is .5
//       //     byte nmap_one = Byte.MaxValue;
//       //     if (NormalMapFormat == NormalMapFormat.Yup)
//       //     {
//       //       t = new Texture2D("default1x1-normal", Img32Generator.Default1x1_RGBA32ub("normalyup", nmap_zero, nmap_one, nmap_zero, Byte.MaxValue), false, TexFilter.Nearest);
//       //     }
//       //     else if (NormalMapFormat == NormalMapFormat.Zup)
//       //     {
//       //       t = new Texture2D("default1x1-normal", Img32Generator.Default1x1_RGBA32ub("normalzup", nmap_zero, nmap_zero, nmap_one, Byte.MaxValue), false, TexFilter.Nearest);
//       //     }
//       //     else
//       //     {
//       //       Gu.BRThrowNotImplementedException();
//       //     }
//       //     _default1x1NormalPixel_RGBA32ub.Set(t);
//       //   }
//       //   return t;
//       // }




//       //  Gu.Lib.DefineMaterial(ResourceID.Obj_Camera, , true);

//       //   public static Material DefaultFlatColor
//       //   {
//       //     get
//       //     {
//       //       if (_defaultFlatColorMaterial == null)
//       //       {
//       //         _defaultFlatColorMaterial = new Material(System.Reflection.MethodBase.GetCurrentMethod().Name, Shader.DefaultFlatColorShader());
//       //         _defaultObjectMaterial.AlbedoSlot.Texture = Texture2D.Default1x1ColorPixel_RGBA32ub(new vec4ub(255, 255, 255, 255));
//       //       }
//       //       return _defaultFlatColorMaterial;
//       //     }
//       //   }
//       //   public static Material DefaultObjectMaterial
//       //   {
//       //     get
//       //     {
//       //       if (_defaultObjectMaterial == null)
//       //       {
//       //         _defaultObjectMaterial = new Material(System.Reflection.MethodBase.GetCurrentMethod().Name, Gu.Lib.GetShader(Rs.Shader.DefaultObjectShader));
//       //         _defaultObjectMaterial.AlbedoSlot.Texture = Texture2D.Default1x1ColorPixel_RGBA32ub(new vec4ub(255, 0, 255, 255));
//       //       }
//       //       return _defaultObjectMaterial;
//       //     }
//       //   }
//       //   public static Material DebugDraw_VertexNormals_FlatColor
//       //   {
//       //     get
//       //     {
//       //       if (_debugdraw_normals_material == null)
//       //       {
//       //         _debugdraw_normals_material = new Material(System.Reflection.MethodBase.GetCurrentMethod().Name,
//       //         Gu.Lib.LoadShader("v_normals", true, FileStorage.Embedded, OpenTK.Graphics.OpenGL4.PrimitiveType.Triangles));
//       //         _debugdraw_normals_material.GpuRenderState.Blend = false;
//       //         _debugdraw_normals_material.BaseColor = new vec4(0.827f, 0.933f, 0.113f, 1);
//       //       }
//       //       return _debugdraw_normals_material;
//       //     }
//       //   }

//     }

//   }


// }

 // [DataContract] [Serializable]
  // public class ResourceDescriptor
  // {
  //   //purpose of this class is to distinguish between resources that exist, and ones that do not,
  //   //when constructing resources (tex/img/model) and load or unload them when they are created.

  //   //if id is zero then make a new resource

  //   public enum ResourceLoadFlags
  //   {
  //     Load,
  //     DoNotLoad
  //   }
  //   public static ResourceDescriptor NONE_Undefined = new ResourceDescriptor(ResourceType.Undefined, "NONE_None", 0);

  //   public static ResourceDescriptor Img32_Default1x1InvalidImage_RGBA32ub = new ResourceDescriptor(ResourceType.Image, "Img32_Default1x1InvalidImage_RGBA32ub", 1);
  //   public static ResourceDescriptor Img32_Default1x1ColorPixel_RGBA32ub = new ResourceDescriptor(ResourceType.Image, "Img32_Default1x1ColorPixel_RGBA32ub", 2);
  //   public static ResourceDescriptor Image_Default1x1NormalPixel_RGBA32ub = new ResourceDescriptor(ResourceType.Image, "Image_Default1x1NormalPixel_RGBA32ub", 3);

  //   public static ResourceDescriptor Tex2D_Default1x1ColorPixel_RGBA32ub = new ResourceDescriptor(ResourceType.Texture, "Tex2D_Default1x1ColorPixel_RGBA32ub", 1);
  //   public static ResourceDescriptor Tex2D_Default1x1NormalPixel_RGBA32ub = new ResourceDescriptor(ResourceType.Texture, "Tex2D_Default1x1NormalPixel_RGBA32ub", 2);

  //   public static ResourceDescriptor Material_DefaultFlatColor = new ResourceDescriptor(ResourceType.Material, "Material_DefaultFlatColor", 1);
  //   public static ResourceDescriptor Material_DefaultObjectMaterial = new ResourceDescriptor(ResourceType.Material, "Material_DefaultObjectMaterial", 2);
  //   public static ResourceDescriptor Material_DebugDraw_VertexNormals_FlatColor = new ResourceDescriptor(ResourceType.Material, "Material_DebugDraw_VertexNormals_FlatColor", 3);

  //   public static ResourceDescriptor Shader_GuiShader = new ResourceDescriptor(ResourceType.Shader, "Shader_GuiShader", 1);

  //   public static ResourceDescriptor WorldObject_Camera = new ResourceDescriptor(ResourceType.WorldObject, "WorldObject_Camera", 1);
  //   public static ResourceDescriptor WorldObject_Gear = new ResourceDescriptor(ResourceType.WorldObject, "WorldObject_Gear", 2);

  //   ///
  //   private static List<ResourceDescriptor> _checkDebugDupes = new List<ResourceDescriptor>();

  //   private string _name = Lib.UnsetName;
  //   private UInt64 _uniqueID = Lib.UnsetID;
  //   private ResourceLoadFlags _loadFlags = ResourceLoadFlags.DoNotLoad;

  //   public string Name { get { return _name; } set { _name = value; } }
  //   public UInt64 UniqueID { get { return _uniqueID; } set { _uniqueID = value; } }
  //   public ResourceLoadFlags LoadFlags { get { return _loadFlags; } set { _loadFlags = value; } }

  //   public ResourceDescriptor(ResourceType type, string name, UInt64 id, ResourceLoadFlags loadFlags = ResourceLoadFlags.DoNotLoad)
  //   {
  //     Gu.Assert(!(type != ResourceType.Undefined && id == 0));
  //     foreach (var rid in _checkDebugDupes)
  //     {
  //       Gu.Assert(rid.Name != name, $"Duplicate default resource ID name '{name}'");
  //       Gu.Assert(rid.UniqueID != id, $"Duplicate default resource ID id '{id}'");
  //     }

  //     _name = name;
  //     _uniqueID = (ulong)(type.IDMultiplier * (ulong)id);
  //     _loadFlags = loadFlags;

  //     _checkDebugDupes.Add(this);
  //   }
  //   public override string ToString()
  //   {
  //     var js = SerializeTools.SerializeJSON(this);
  //     return js;
  //   }
  // }


     // bool global_flip_tris = true;

      //_defaultFlatColorMaterial = new Material(System.Reflection.MethodBase.GetCurrentMethod().Name, Shader.DefaultFlatColorShader());
      //         _defaultObjectMaterial.AlbedoSlot.Texture = Texture2D.Default1x1ColorPixel_RGBA32ub(new vec4ub(255, 255, 255, 255));

/*

ok so

if model name exists
  craet new 
  DefinEmodel
    TryDefineModel - 

*/

      //Camera model
      // Gu.Lib.DefineModel(new ModelLoader(ResourceDescriptor.WorldObject_Camera, new FileLoc("camera.glb", FileStorage.Embedded), global_flip_tris));
      // Gu.Lib.DefineShader(new ShaderLoader(ResourceDescriptor.Shader_GuiShader, "v_gui", true, FileStorage.Embedded, OpenTK.Graphics.OpenGL4.PrimitiveType.Points));
      // Gu.Lib.DefineImage(Img32Generator.Default1x1_RGBA32ub(ResourceDescriptor.Img32_Default1x1InvalidImage_RGBA32ub, Byte.MaxValue, 0, Byte.MaxValue, Byte.MaxValue));
      // Gu.Lib.DefineImage(Img32Generator.Default1x1_RGBA32ub(ResourceDescriptor.Img32_Default1x1ColorPixel_RGBA32ub, Byte.MaxValue, Byte.MaxValue, Byte.MaxValue, Byte.MaxValue), out var imgcolor);

      // //Normal maps..
      // byte nmap_zero = Byte.MaxValue / 2;//zero in normal map is .5
      // byte nmap_one = Byte.MaxValue;
      // if (Texture2D.NormalMapFormat == NormalMapFormat.Yup)
      // {
      //   if (Gu.Lib.DefineImage(Img32Generator.Default1x1_RGBA32ub(ResourceDescriptor.Image_Default1x1NormalPixel_RGBA32ub, nmap_zero, nmap_one, nmap_zero, Byte.MaxValue), out var imgyup))
      //   {
      //     var tex = new Texture2D(ResourceDescriptor.Tex2D_Default1x1NormalPixel_RGBA32ub.Description(), imgyup, false, TexFilter.Nearest);
      //     tex.Save();
      //   }
      // }
      // else if (Texture2D.NormalMapFormat == NormalMapFormat.Zup)
      // {
      //   //t = new Texture2D("default1x1-normal", Img32Generator.Default1x1_RGBA32ub("normalzup", nmap_zero, nmap_zero, nmap_one, Byte.MaxValue), false, TexFilter.Nearest);
      //   if (Gu.Lib.DefineImage(Img32Generator.Default1x1_RGBA32ub(ResourceDescriptor.Image_Default1x1NormalPixel_RGBA32ub, nmap_zero, nmap_zero, nmap_one, Byte.MaxValue), out var imgzup))
      //   {
      //     var tex = new Texture2D(ResourceDescriptor.Tex2D_Default1x1NormalPixel_RGBA32ub.Description(), imgzup, false, TexFilter.Nearest);
      //     tex.Save();
      //   }
      // }
      // else
      // {
      //   Gu.BRThrowNotImplementedException();
      // }

      //DefaultFlatColor


      // public static Texture2D Default1x1ColorPixel_RGBA32ub(vec4ub color)
      // {
      //   var t = _default1x1ColorPixel_RGBA32ub.Get();
      //   if (t == null)
      //   {
      //     t = new Texture2D("default1x1-color", , false, TexFilter.Nearest);
      //     _default1x1ColorPixel_RGBA32ub.Set(t);
      //   }
      //   return t;
      // }
      // public static Texture2D Default1x1NormalPixel_RGBA32ub()
      // {
      //   var t = _default1x1NormalPixel_RGBA32ub.Get();
      //   if (t == null)
      //   {
      //     byte nmap_zero = Byte.MaxValue / 2;//zero in normal map is .5
      //     byte nmap_one = Byte.MaxValue;
      //     if (NormalMapFormat == NormalMapFormat.Yup)
      //     {
      //       t = new Texture2D("default1x1-normal", Img32Generator.Default1x1_RGBA32ub("normalyup", nmap_zero, nmap_one, nmap_zero, Byte.MaxValue), false, TexFilter.Nearest);
      //     }
      //     else if (NormalMapFormat == NormalMapFormat.Zup)
      //     {
      //       t = new Texture2D("default1x1-normal", Img32Generator.Default1x1_RGBA32ub("normalzup", nmap_zero, nmap_zero, nmap_one, Byte.MaxValue), false, TexFilter.Nearest);
      //     }
      //     else
      //     {
      //       Gu.BRThrowNotImplementedException();
      //     }
      //     _default1x1NormalPixel_RGBA32ub.Set(t);
      //   }
      //   return t;
      // }




      //  Gu.Lib.DefineMaterial(ResourceID.Obj_Camera, , true);

      //   public static Material DefaultFlatColor
      //   {
      //     get
      //     {
      //       if (_defaultFlatColorMaterial == null)
      //       {
      //         _defaultFlatColorMaterial = new Material(System.Reflection.MethodBase.GetCurrentMethod().Name, Shader.DefaultFlatColorShader());
      //         _defaultObjectMaterial.AlbedoSlot.Texture = Texture2D.Default1x1ColorPixel_RGBA32ub(new vec4ub(255, 255, 255, 255));
      //       }
      //       return _defaultFlatColorMaterial;
      //     }
      //   }
      //   public static Material DefaultObjectMaterial
      //   {
      //     get
      //     {
      //       if (_defaultObjectMaterial == null)
      //       {
      //         _defaultObjectMaterial = new Material(System.Reflection.MethodBase.GetCurrentMethod().Name, Gu.Lib.GetShader(Rs.Shader.DefaultObjectShader));
      //         _defaultObjectMaterial.AlbedoSlot.Texture = Texture2D.Default1x1ColorPixel_RGBA32ub(new vec4ub(255, 0, 255, 255));
      //       }
      //       return _defaultObjectMaterial;
      //     }
      //   }
      //   public static Material DebugDraw_VertexNormals_FlatColor
      //   {
      //     get
      //     {
      //       if (_debugdraw_normals_material == null)
      //       {
      //         _debugdraw_normals_material = new Material(System.Reflection.MethodBase.GetCurrentMethod().Name,
      //         Gu.Lib.LoadShader("v_normals", true, FileStorage.Embedded, OpenTK.Graphics.OpenGL4.PrimitiveType.Triangles));
      //         _debugdraw_normals_material.GpuRenderState.Blend = false;
      //         _debugdraw_normals_material.BaseColor = new vec4(0.827f, 0.933f, 0.113f, 1);
      //       }
      //       return _debugdraw_normals_material;
      //     }
      //   }



    #region Public Static: Methods

    public static DataBlock? ConstructResource(ResourceType rt)
    {
      //we mighjt use this.. or just delete it
      // if (rt == ResourceType.WorldObject)
      // {
      //   return new WorldObject();
      // }
      // else if (rt == ResourceType.MeshData)
      // {
      //   return new MeshData();
      // }
      // else if (rt == ResourceType.Material)
      // {
      //   return new Material();
      // }
      // else if (rt == ResourceType.Img32)
      // {
      //   return new Img32();
      // }      
      // else if (rt == ResourceType.Texture2D)
      // {
      //   Gu.BRThrowNotImplementedException();//hmm... this is hard
      //   //return new Texture2D();
      // }            
      // else if (rt == ResourceType.AnimationComponent)
      // {
      //   return new AnimationComponent();
      // }
      // else if (rt == ResourceType.EventComponent)
      // {
      //   return new EventComponent();
      // }
      // else if (rt == ResourceType.FPSInputComponent)
      // {
      //   return new FPSInputComponent();
      // }

      Gu.BRThrowNotImplementedException();
      return null;
    }

    #endregion


        public void ChangeResource(ResourceNode? rsc)
    {
      _resource = rsc;
    }


    // private void LoadResourceFile(FileMode savemode = FileMode.Text)
    // {
    //   //Try loading resources from embed, if it doesn't exist, use the /data resources
    //   //in both cases, we modify only /data of coruse.
    //   FileLoc fl = GetResourceFileLoc(savemode);

    //   if (!fl.Exists)
    //   {
    //     Gu.Log.Info($"File does not exist, Creating new resource file '{fl.QualifiedPath}'");
    //     SaveResourceFile();
    //   }
    //   else if (savemode == FileMode.Text)
    //   {
    //     var json = fl.ReadAllText();
    //     var deserialized_resources_byid = (Dictionary<ulong, ResourceNode>)JsonConvert.DeserializeObject(json, typeof(Dictionary<ulong, ResourceNode>));
    //     if (deserialized_resources_byid == null || deserialized_resources_byid.Count == 0)
    //     {
    //       Gu.Log.Error("Resources was null");
    //       //   Gu.DebugBreak();
    //     }
    //     else
    //     {
    //       //Build tables
    //       foreach (var r in deserialized_resources_byid)
    //       {
    //         AddResource(r.Value);
    //       }
    //     }
    //   }
    //   else
    //   {
    //     Gu.MustTest();
    //     var enc = Encoding.GetEncoding("iso-8859-1");
    //     using (var fs = fl.OpenRead())
    //     using (var bwFile = new System.IO.BinaryReader(fs, enc))
    //     {
    //       _resourcesById = SerializeTools.DeserializeDictionary<UInt64, ResourceNode>(bwFile, c_fileVersion);
    //     }
    //   }
    // }
    // private ResourceNode? GetNode(ResourceDescriptor rd)
    // {
    //   return GetNode((UInt64)rd.UniqueID);
    // }
    // private ResourceNode? GetNode(UInt64 id)
    // {
    //   if (_resourcesById.TryGetValue(id, out var rr))
    //   {
    //     return rr;
    //   }

    //   //for now we throw since they are hard coded, 
    //   //later if we auto-generate the file, we can add new resources and save the file, but we
    //   //will need to figure out how to package it.
    //   Gu.BRThrowException($"Resource id '{id}' not found");

    //   return null;
    // }

    // public T? LoadResource<T>(ResourceDescriptor resID) where T : DataBlock
    // {
    //   T? ret = null;
    //   var rsc = LoadResource(resID.UniqueID);
    //   if (rsc == null)
    //   {
    //     Gu.Log.Error($"Could not find resource '{resID.Name}' id={resID}.");
    //   }
    //   else
    //   {
    //     ret = (T?)rsc;
    //   }
    //   return ret;
    // }
    // private DataBlock? LoadResource(ResourceNode resNode)
    // {
    //   Gu.Assert(resNode != null);
    //   return LoadResource(resNode.UniqueID);
    // }
    // private DataBlock? LoadResource(UInt64 resID)
    // {
    //   DataBlock? db = null;
    //   var rsc = GetResourceById(resID);
    //   if (rsc != null)
    //   {
    //     if (!rsc.HasRef)
    //     {
    //       Gu.BRThrowNotImplementedException();
    //       //load
    //       //rsc._resourceLoadREsult.. = ..
    //       //
    //       //if (rsc is DataSource)
    //       //{
    //       //  //This is also for texture / model data.
    //       //  CacheResource(rsc as DataSource);//only cache the resource when we actually load it, not define it.
    //       //}
    //     }
    //     else
    //     {
    //       rsc.Ref.TryGetTarget(out db);
    //     }
    //   }
    //   return db;
    // }
    // private bool TryUnloadResource(ResourceNode n)
    // {
    //   Gu.Assert(n != null);
    //   //If there are active handles to this resource then it won't be unloaded
    //   n.Ref = null;
    //   return true;
    // }

    public DataBlock? GetOrLoadExistingResource(UInt64 id)
    {
      // //resources get serialized in binary as parameter references to files.
      // //but we save the resource id->name mapping as a JSON in case a resource name changes (by accident).

      // //This will only work once ALL of the resources for the World have been loaded.
      // //YOu must load all resources first so they are in this table.

      // //The scenegraph should root to a Loader of some kind. The loader is also serialized, and can then create the object.

      DataBlock? ret = null;
      // var rr = GetNode(id);
      // var msghead = $"Resource type '{rr.ResType.ToString()}'  id '{id}':";
      // var notsupportedmsg = $"{msghead} loader not supported.";
      // var nofilesmsg = $"{msghead} had no files.";

      // if (rr == null)
      // {
      //   Gu.Log.Error($"Existing resource '{id}' was not found. Make sure the entire scene is deserialized before dereferencing sub-objects.");
      //   Gu.DebugBreak();
      // }
      // else
      // {
      //   //If rr is not null, but it has no ref,
      //   //then we may have loaded the resource file, but we may have not loaded the entire binary scene

      //   if (rr.Ref != null)
      //   {
      //     if (rr.Ref.TryGetTarget(out var db))
      //     {
      //       //return main handle to the resource
      //       return db;
      //     }
      //     //The datablock went away, (likely manually uload()), set to null.
      //     rr.Ref = null;
      //   }

      //   if (rr.ResType == ResourceType.GLTFFile)
      //   {
      //     //         FileLoc loc = rr.Properties.GetFileLoc(ResourceProperty.FileLoc);
      //     // bool flip_tris = rr.Properties.GetBool(ResourceProperty.FlipTris);
      //     //   LoadObjects(loc,flip_tris);
      //   }
      //   else if (rr.ResType == ResourceType.Shader)
      //   {
      //   }
      //   else if (rr.ResType == ResourceType.PNGFile)
      //   {
      //     //   Gu.Assert(rr.Properties != null);

      //     // var loc = rr.Properties.GetFileLoc(ResourceProperty.FileLoc);

      //     // rr.Ref = new WeakReference<DataBlock>(img);
      //     //   LoadImage(rr);
      //   }

      //   if (rr.Dependencies.Count > 0)
      //   {
      //     foreach (var dep in rr.Dependencies)
      //     {
      //       GetOrLoadExistingResource(dep);
      //     }
      //   }

      //   //Resource must be loaded, the node graph must already exist if we get here.
      //   if (rr.Ref == null)
      //   {
      //     Gu.BRThrowException("Resource could not be loaded.");
      //   }
      //   if (rr.Ref.TryGetTarget(out ret))
      //   {
      //     Gu.BRThrowException("Resource could not be loaded.");
      //   }
      // }

      // Gu.BRThrowNotImplementedException();
      return ret;
    }

    // public DataBlock? CreateNewResource(DataBlock baseClass, string name)
    // {
    //   var rsc = GetResourceByName(baseClass.ResourceType, name);
    //   if (rsc != null)
    //   {
    //     Gu.BRThrowException(
    //       $"Tried to create resource with duplicate name '{name}':\n {rsc.ToString()} \n"
    //     + $" *Use GetUniqueName() to ensure unique name.\n");
    //   }
    //   var id = GetNewUniqueId();
    //   ResourceNode rn = new ResourceNode(name, baseClass.ResourceType, id);
    //   //we have to add new resources being that, we need to know what id's/names are unique and not
    //   AddResource(rn);
    //   //type/file is only valid for type resources
    //   return rn;
    // }

        // public void DestroyObject(WorldObject ob)
    // {
    //   ob.State = WorldObjectState.Destroyed;
    // }    
    // private void DestroyObjectInternal(WorldObject wo)
    // {
    //   //prevent modifying list in for loop
    //   wo.UpdateResource(ResourceUpdateMode.Remove);
    //   wo.UnlinkHierarchy();
    //   wo.OnDestroyed?.Invoke(wo);
    //   wo.IterateComponentsSafe((cmp) =>
    //   {
    //     cmp.OnDestroy(wo);
    //     return LambdaBool.Continue;
    //   });
    //   _worldEdited = true;
    // }


  // public class DeferredFramebuffer : FramebufferGeneric
  // {
  //   public const string c_strColorMRT_DF = "ColorMRT-deferred";
  //   public const string c_strNormalMRT_DF = "NormalMRT-deferred";
  //   public const string c_strPlaneMRT_DF = "PlaneMRT-deferred";
  //   public const string c_strPositionMRT_DF = "PositionMRT-deferred";

  //   public DeferredFramebuffer(bool bMultisample, int nSamples, vec4 vClear) : base("Deferred_FBO", bMultisample, nSamples, vClear)
  //   {
  //     //  _pBloomVaoPass = NULL;
  //   }
  //   //virtual ~DeferredFramebuffer() override;

  //   public override void Init(int w, int h, FramebufferAttachment sharedDepth, FramebufferAttachment sharedPick)
  //   {
  //     DeleteTargets();

  //     bool _bUseRenderBuffer = false;

  //     //TODO: later we'll create this async.
  //     //Gd::verifyRenderThread();
  //     _glId = GL.GenFramebuffer();
  //     Gpu.CheckGpuErrorsRt();

  //     Bind(FramebufferTarget.Framebuffer);

  //     GL.FramebufferParameter(FramebufferTarget.Framebuffer, FramebufferDefaultParameter.FramebufferDefaultWidth, w);
  //     Gpu.CheckGpuErrorsRt();
  //     GL.FramebufferParameter(FramebufferTarget.Framebuffer, FramebufferDefaultParameter.FramebufferDefaultHeight, h);
  //     Gpu.CheckGpuErrorsRt();
  //     GL.ActiveTexture(TextureUnit.Texture0);
  //     Gpu.CheckGpuErrorsRt();

  //     string msaa = this._bMsaaEnabled ? "-msaa" : "";
  //     // - Textures
  //     //Don't change the names here, we reference them elsewhere *yikes*
  //     //These must match the order in the shader
  //     AddAttachment(c_strColorMRT_DF + msaa, PixelInternalFormat.Rgba32f, PixelFormat.Rgba, PixelType.Float, w, h, RenderTargetType.Color);//0
  //     AddAttachment(sharedPick);//1
  //     AddAttachment(c_strNormalMRT_DF + msaa, PixelInternalFormat.Rgba32f, PixelFormat.Rgba, PixelType.Float, w, h, RenderTargetType.Normal);//2
  //     AddAttachment(c_strPositionMRT_DF + msaa, PixelInternalFormat.Rgba32f, PixelFormat.Rgba, PixelType.Float, w, h, RenderTargetType.Position);//3 GL_RGBA32F GL_RGBA GL_FLOAT
  //     AddAttachment(c_strPlaneMRT_DF + msaa, PixelInternalFormat.Rgba32f, PixelFormat.Rgba, PixelType.Float, w, h, RenderTargetType.Mat0);//4
  //     sharedDepth.Attach();

  //     CheckFramebufferComplete();

  //     SetObjectLabel();

  //     Unbind(FramebufferTarget.DrawFramebuffer);
  //     UnbindRenderbuffer();

  //     _eState = FramebufferState.Initialized;
  //   }

  //   public override void BeginRender()
  //   {
  //     if (_eState != FramebufferState.Initialized)
  //     {
  //       Gu.BRThrowException("Framebuffer was not initialized.");
  //     }

  //     Bind(FramebufferTarget.DrawFramebuffer);
  //     UnbindRenderbuffer();
  //     SetDrawAllTargets();

  //     //NOTE:
  //     //CRITICAL that clear color is zero here.
  //     // Otherwise the color somehow shows up in random places getting
  //     // blended with other colors..
  //     GL.ClearColor(ClearColor.r, ClearColor.g, ClearColor.b, ClearColor.a);
  //     GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
  //     Gpu.CheckGpuErrorsDbg();
  //   }
  //   public override void EndRender()
  //   {
  //     Unbind(FramebufferTarget.DrawFramebuffer);
  //   }

  // }
  // public class ForwardFramebuffer : FramebufferGeneric
  // {
  //   public const string c_strColorMRT_FW = "ColorMRT-forward";

  //   public ForwardFramebuffer(bool bMsaa, int nMsaa, vec4 vClear) : base("Forward_Framebuffer", bMsaa, nMsaa, vClear)
  //   {
  //   }
  //   public override void Init(int iWidth, int iHeight, FramebufferAttachment sharedDepth, FramebufferAttachment sharedPick)
  //   {
  //     DeleteTargets();

  //     GL.UseProgram(0);
  //     Unbind(FramebufferTarget.Framebuffer);
  //     UnbindRenderbuffer();

  //     _glId = GL.GenFramebuffer();
  //     GL.BindFramebuffer(FramebufferTarget.Framebuffer, _glId);
  //     GL.FramebufferParameter(FramebufferTarget.Framebuffer, FramebufferDefaultParameter.FramebufferDefaultWidth, iWidth);
  //     GL.FramebufferParameter(FramebufferTarget.Framebuffer, FramebufferDefaultParameter.FramebufferDefaultHeight, iHeight);
  //     Gpu.CheckGpuErrorsRt();
  //     string msaa = this._bMsaaEnabled ? "-msaa" : "";

  //     AddAttachment(c_strColorMRT_FW + msaa, PixelInternalFormat.Rgba32f, PixelFormat.Rgba, PixelType.Float, iWidth, iHeight, RenderTargetType.Color);
  //     AddAttachment(sharedPick);
  //     sharedDepth.Attach();

  //     CheckFramebufferComplete();

  //     SetObjectLabel();

  //     //Return to default.
  //     GL.UseProgram(0);

  //     Unbind(FramebufferTarget.Framebuffer);
  //     UnbindRenderbuffer();

  //     _eState = FramebufferState.Initialized;
  //   }


  //   public override void BeginRender()
  //   {
  //     if (_eState != FramebufferState.Initialized)
  //     {
  //       Gu.BRThrowException("Framebuffer was not initialized.");
  //     }

  //     //Clear all buffers
  //     Bind(FramebufferTarget.DrawFramebuffer);
  //     UnbindRenderbuffer();//_depthRenderBufferId);

  //     //Do not clear! - previous deferred operation is in here. (clear happens in clearFb)
  //     //**Do not clear***
  //     //**Do not clear***
  //     //**Do not clear***
  //     //**Do not clear***
  //     //**Do not clear***
  //     //**Do not clear***

  //   }
  //   public override void EndRender()
  //   {
  //     //noting
  //   }
  //   public void ClearSharedFb()
  //   {
  //     //Call this before we begin the defrred
  //     Bind(FramebufferTarget.DrawFramebuffer);
  //     UnbindRenderbuffer();
  //     SetDrawAllTargets();

  //     GL.ClearColor(ClearColor.r, ClearColor.g, ClearColor.b, ClearColor.a);
  //     GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
  //     Unbind(FramebufferTarget.DrawFramebuffer);
  //   }

  // };



  public struct UiQuad
  {
    public vec4 _val = vec4.Zero;
    public static UiQuad Zero { get { return new UiQuad() { _val = vec4.Zero }; } }

    //Using box2f with overriden props was not good, was causing a lot of errors
    public float _left { get { return _val.x; } set { _val.x = value; } }
    public float _top { get { return _val.y; } set { _val.y = value; } }
    public float _right { get { return _val.z; } set { _val.z = value; } }
    public float _bot { get { return _val.w; } set { _val.w = value; } }
    public float _width { get { return _right - _left; } set { _right = _left + value; } }
    public float _height { get { return _bot - _top; } set { _bot = _top + value; } }

    public float left { get { return _val.w; } set { _val.w = value; } }
    public float top { get { return _val.x; } set { _val.x = value; } }
    public float right { get { return _val.y; } set { _val.y = value; } }
    public float bot { get { return _val.z; } set { _val.z = value; } }

    //public float _left = 0;
    //public float _top = 0;
    //public float _width = 0;
    //public float _height = 0;
    public vec2 Max { get { return new vec2(_right, _bot); } }
    public vec2 Min { get { return new vec2(_left, _top); } }
    // public float Top { get { return _top; } }
    // public float Left { get { return _left; } }
    // public float Right { get { return _left + _width; } }
    // public float Bottom { get { return _top + _height; } }

    public UiQuad() { }
    public UiQuad(float dt, float dr, float db, float dl)
    {
      _top = dt;
      _right = dr;
      _bot = db;
      _left = dl;
    }
    public UiQuad Clone()
    {
      return new UiQuad(){ _val = this._val };
    }
    public bool Validate(bool debug_break = true, float min_volume = 0)
    {
      return this.ToBox().Validate(debug_break, min_volume);
    }
    public void ExpandByPoint(vec2 v)
    {
      var b = ToBox();
      b.ExpandByPoint(v);
      FromBox(b);
    }
    public Box2f ToBox()
    {
      return new Box2f(_left, _top, _width, _height);
    }
    public void FromBox(Box2f bx)
    {
      this._left = bx._min.x;
      this._top = bx._min.y;
      this._width = bx.Width;
      this._height = bx.Height;
    }
    public bool ShrinkByBox(UiQuad b)
    {
      var bx = this.ToBox();
      bx.ShrinkByBox(b.ToBox());
      FromBox(bx);
      return true;
    }
    public float LSize(UiLayoutOrientation dir)
    {
      //get size dimension for layotu
      if (dir == UiLayoutOrientation.Horizontal)
      {
        return _width;